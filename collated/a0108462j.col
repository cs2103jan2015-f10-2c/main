//@author: a0108462j



	/**
	 * origin: C:\Users\SKR\Documents\main\iLogic\DateTimeVerification.cpp
	 */


#include <assert.h>
#include <exception>
#include "DateTimeVerification.h"

const int DateTimeVerification::DATETIME_VERIFICATION_MIN_YEAR = 0;
const int DateTimeVerification::DATETIME_VERIFICATION_MAX_YEAR = 9999;
const int DateTimeVerification::DATETIME_VERIFICATION_MIN_MONTH = 1;
const int DateTimeVerification::DATETIME_VERIFICATION_MAX_MONTH = 12;
const int DateTimeVerification::DATETIME_VERIFICATION_MIN_DAY = 1;
const int DateTimeVerification::DATETIME_VERIFICATION_MAX_DAY = 31;
const int DateTimeVerification::DATETIME_VERIFICATION_MIN_HOUR = 0;
const int DateTimeVerification::DATETIME_VERIFICATION_MAX_HOUR = 23;
const int DateTimeVerification::DATETIME_VERIFICATION_MIN_MINUTE = 0;
const int DateTimeVerification::DATETIME_VERIFICATION_MAX_MINUTE = 59;
const int DateTimeVerification::DATETIME_VERIFICATION_EMPTYFIELD_DATETIME = -1;
const int DateTimeVerification::DATETIME_VERIFICATION_INT_MINUS_TWO = -2;

const int DateTimeVerification::DATETIME_VERIFICATION_DAY_29 = 29;
const int DateTimeVerification::DATETIME_VERIFICATION_DAY_30 = 30;
const int DateTimeVerification::DATETIME_VERIFICATION_DAY_31 = 31;
const int DateTimeVerification::DATETIME_VERIFICATION_MONTH_FEB = 2;
const int DateTimeVerification::DATETIME_VERIFICATION_MONTH_APR = 4;
const int DateTimeVerification::DATETIME_VERIFICATION_MONTH_JUN = 6;
const int DateTimeVerification::DATETIME_VERIFICATION_MONTH_SEP = 9;
const int DateTimeVerification::DATETIME_VERIFICATION_MONTH_NOV = 11;
const int DateTimeVerification::DATETIME_VERIFICATION_YEAR_4 = 4;
const int DateTimeVerification::DATETIME_VERIFICATION_YEAR_100 = 100;
const int DateTimeVerification::DATETIME_VERIFICATION_YEAR_400 = 400;

const string DateTimeVerification::DATETIME_VERIFICATION_EXCEPTION_LESS_THAN_MINUS_TWO = "Date/Time value less than -2";

DateTimeVerification::DateTimeVerification(DateTime dateTimeObject) {
	_dateTimeObjectToVerify = dateTimeObject;
	_year = _dateTimeObjectToVerify.getYear();
	_month = _dateTimeObjectToVerify.getMonth();
	_day = _dateTimeObjectToVerify.getDay();
	_hour = _dateTimeObjectToVerify.getHour();
	_minute = _dateTimeObjectToVerify.getMinute();
}

bool DateTimeVerification::isValidDateTimeValues() {
	if (isValidYearRange() &&
		isValidMonthRange() &&
		isValidDayRange() &&
		isValidHourRange() &&
		isValidMinuteRange()) {
		return true;
	} else {
		return false;
	}
}

bool DateTimeVerification::isValidYearRange() {
	if (_year >= DATETIME_VERIFICATION_MIN_YEAR && _year <= DATETIME_VERIFICATION_MAX_YEAR) {
		return true;
	} else if (_year == DATETIME_VERIFICATION_EMPTYFIELD_DATETIME) {
		return true;
	} else {
		assert(_year > DATETIME_VERIFICATION_MAX_YEAR || _year < DATETIME_VERIFICATION_EMPTYFIELD_DATETIME);
		return false;
	}
}

bool DateTimeVerification::isValidMonthRange() {
	if (_month >= DATETIME_VERIFICATION_MIN_MONTH && _month <= DATETIME_VERIFICATION_MAX_MONTH) {
		return true;
	} else if (_month == DATETIME_VERIFICATION_EMPTYFIELD_DATETIME) {
		return true;
	} else {
		assert(_month > DATETIME_VERIFICATION_MAX_MONTH || _month < DATETIME_VERIFICATION_EMPTYFIELD_DATETIME);
		return false;
	}
}

bool DateTimeVerification::isValidDayRange() {
	if (_day >= DATETIME_VERIFICATION_MIN_DAY && _day <= DATETIME_VERIFICATION_MAX_DAY) {
		return true;
	} else if (_day == DATETIME_VERIFICATION_EMPTYFIELD_DATETIME) {
		return true;
	} else {
		assert(_day > DATETIME_VERIFICATION_MAX_DAY || _day < DATETIME_VERIFICATION_EMPTYFIELD_DATETIME);
		return false;
	}
}

bool DateTimeVerification::isValidHourRange() {
	if (_hour >= DATETIME_VERIFICATION_MIN_HOUR && _hour <= DATETIME_VERIFICATION_MAX_HOUR) {
		return true;
	} else if (_hour == DATETIME_VERIFICATION_EMPTYFIELD_DATETIME) {
		return true;
	} else {
		assert(_hour > DATETIME_VERIFICATION_MAX_HOUR || _hour < DATETIME_VERIFICATION_EMPTYFIELD_DATETIME);
		return false;
	}
}

bool DateTimeVerification::isValidMinuteRange() {
	if (_minute >= DATETIME_VERIFICATION_MIN_MINUTE && _minute <= DATETIME_VERIFICATION_MAX_MINUTE) {
		return true;
	} else if (_minute == DATETIME_VERIFICATION_EMPTYFIELD_DATETIME) {
		return true;
	} else {
		assert(_minute > DATETIME_VERIFICATION_MAX_HOUR || _minute < DATETIME_VERIFICATION_EMPTYFIELD_DATETIME);
		return false;
	}
}

bool DateTimeVerification::hasYearMonthDay() {
	if (hasYear() && hasMonth() && hasDay()) {
		return true;
	} else {
		return false;
	}
}

bool DateTimeVerification::hasMonthDay() {
	if (!hasYear() && hasMonth() && hasDay()) {
		return true;
	} else {
		return false;
	}
}

bool DateTimeVerification::hasYear() {
	try {
		if (!isValidYearRange()) {
			return false;
		} else if (_year == DATETIME_VERIFICATION_EMPTYFIELD_DATETIME) {
			return false;
		} else if (_year <DATETIME_VERIFICATION_INT_MINUS_TWO) {
			throw DATETIME_VERIFICATION_EXCEPTION_LESS_THAN_MINUS_TWO;
		} else {
			return true;
		}
	} catch (string errorMessage) {
		cerr << errorMessage << endl;
	}
}

bool DateTimeVerification::hasMonth() {
	try {
		if (!isValidMonthRange()) {
			return false;
		} else if (_month == DATETIME_VERIFICATION_EMPTYFIELD_DATETIME) {
			return false;
		} else if (_month <DATETIME_VERIFICATION_INT_MINUS_TWO) {
			throw DATETIME_VERIFICATION_EXCEPTION_LESS_THAN_MINUS_TWO;
		} else {
			return true;
		}
	} catch (string errorMessage) {
		cerr << errorMessage << endl;
	}
}

bool DateTimeVerification::hasDay() {
	try {
		if (!isValidDayRange()) {
			return false;
		} else if (_day == DATETIME_VERIFICATION_EMPTYFIELD_DATETIME) {
			return false;
		} else if (_day <DATETIME_VERIFICATION_INT_MINUS_TWO) {
			throw DATETIME_VERIFICATION_EXCEPTION_LESS_THAN_MINUS_TWO;
		} else {
			return true;
		}
	} catch (string errorMessage) {
		cerr << errorMessage << endl;
	}
}

bool DateTimeVerification::hasHourMinute() {
	try {
		if (hasHour() && hasMinute()) {
			return true;
		} else if (_hour < DATETIME_VERIFICATION_INT_MINUS_TWO || _minute < DATETIME_VERIFICATION_INT_MINUS_TWO) {
			throw DATETIME_VERIFICATION_EXCEPTION_LESS_THAN_MINUS_TWO;
		} else {
			return false;
		}
	} catch (string errorMessage) {
		cerr << errorMessage << endl;
	}
}

bool DateTimeVerification::hasHour() {
	try {
		if (_hour >= DATETIME_VERIFICATION_MIN_HOUR && _hour <= DATETIME_VERIFICATION_MAX_HOUR) {
			return true;
		} else if (_hour < DATETIME_VERIFICATION_INT_MINUS_TWO) {
			throw DATETIME_VERIFICATION_EXCEPTION_LESS_THAN_MINUS_TWO;
		} else {
			return false;
		}
	} catch (string errorMessage) {
		cerr << errorMessage << endl;
	}
}

bool DateTimeVerification::hasMinute() {
	try {
		if (_minute >= DATETIME_VERIFICATION_MIN_MINUTE && _minute <= DATETIME_VERIFICATION_MAX_MINUTE) {
			return true;
		} else if (_minute < DATETIME_VERIFICATION_INT_MINUS_TWO) {
			throw DATETIME_VERIFICATION_EXCEPTION_LESS_THAN_MINUS_TWO;
		} else {
			return false;
		}
	} catch (string errorMessage) {
		cerr << errorMessage << endl;
	}
}


bool DateTimeVerification::isValidTime() {
	if (hasHour() && hasMinute()) {
		return true;
	} else if (!hasHour() && !hasMinute()) {
		return true;
	} else {
		return false;
	}
}

bool DateTimeVerification::isActualYearMonthDayDate() {
	if ((_day == DATETIME_VERIFICATION_DAY_31) && (_month == DATETIME_VERIFICATION_MONTH_FEB || _month == DATETIME_VERIFICATION_MONTH_APR || _month == DATETIME_VERIFICATION_MONTH_JUN || _month == DATETIME_VERIFICATION_MONTH_SEP || _month == DATETIME_VERIFICATION_MONTH_NOV)) {
		return false;
	} else if ((_day == DATETIME_VERIFICATION_DAY_30) && (_month == DATETIME_VERIFICATION_MONTH_FEB)) {
		return false;
	} else if ((_month == DATETIME_VERIFICATION_MONTH_FEB) && (_day == DATETIME_VERIFICATION_DAY_29) && (_year % DATETIME_VERIFICATION_YEAR_4 != 0)) {
		return false;
	} else if ((_month == DATETIME_VERIFICATION_MONTH_FEB) && (_day == DATETIME_VERIFICATION_DAY_29) && (_year % DATETIME_VERIFICATION_YEAR_400 == 0)) {
		return true;
	} else if ((_month == DATETIME_VERIFICATION_MONTH_FEB) && (_day == DATETIME_VERIFICATION_DAY_29) && (_year % DATETIME_VERIFICATION_YEAR_100 == 0)) {
		return false;
	} else if ((_month == DATETIME_VERIFICATION_MONTH_FEB) && (_day == DATETIME_VERIFICATION_DAY_29) && (_year % DATETIME_VERIFICATION_YEAR_4 == 0)) {
		return true;
	} else {
		return true;
	}
}


////					   ////
////PUBLIC FUNCTIONS BELOW ////
////					   ////


bool DateTimeVerification::isValidDateTime() {
	if (isValidDateTimeValues()) {
		if (hasYearMonthDay() && isActualYearMonthDayDate() && isValidTime()) {
			return true;
		} else if (!hasYear() && !hasMonth() && !hasDay() && !hasHour() && !hasMinute()) {
			return true;
		} else {
			return false;
		}
	} else {
		return false;
	}
}
	// End of segment: C:\Users\SKR\Documents\main\iLogic\DateTimeVerification.cpp





	/**
	 * origin: C:\Users\SKR\Documents\main\iLogic\DateTimeVerification.h
	 */


#ifndef DATETIME_VERIFICATION_H
#define DATETIME_VERIFICATION_H

#include <string>
#include <iostream>
#include "..\iStorage\DateTime.h"
#include "..\iPlanner Log\Log.h"
using namespace std;

class DateTimeVerification {

private:

	static const int DATETIME_VERIFICATION_MIN_YEAR;
	static const int DATETIME_VERIFICATION_MAX_YEAR;
	static const int DATETIME_VERIFICATION_MIN_MONTH;
	static const int DATETIME_VERIFICATION_MAX_MONTH;
	static const int DATETIME_VERIFICATION_MIN_DAY;
	static const int DATETIME_VERIFICATION_MAX_DAY;
	static const int DATETIME_VERIFICATION_MIN_HOUR;
	static const int DATETIME_VERIFICATION_MAX_HOUR;
	static const int DATETIME_VERIFICATION_MIN_MINUTE;
	static const int DATETIME_VERIFICATION_MAX_MINUTE;
	static const int DATETIME_VERIFICATION_EMPTYFIELD_DATETIME;
	static const int DATETIME_VERIFICATION_INT_MINUS_TWO;

	static const int DATETIME_VERIFICATION_DAY_29;
	static const int DATETIME_VERIFICATION_DAY_30;
	static const int DATETIME_VERIFICATION_DAY_31;
	static const int DATETIME_VERIFICATION_MONTH_FEB;
	static const int DATETIME_VERIFICATION_MONTH_APR;
	static const int DATETIME_VERIFICATION_MONTH_JUN;
	static const int DATETIME_VERIFICATION_MONTH_SEP;
	static const int DATETIME_VERIFICATION_MONTH_NOV;
	static const int DATETIME_VERIFICATION_YEAR_4;
	static const int DATETIME_VERIFICATION_YEAR_100;
	static const int DATETIME_VERIFICATION_YEAR_400;

	static const string DATETIME_VERIFICATION_EXCEPTION_LESS_THAN_MINUS_TWO;

	Log _dateTimeVerificationLogger;
	DateTime _dateTimeObjectToVerify;
	int _year;
	int _month;
	int _day;
	int _hour;
	int _minute;

	////////////////////////////
	////// LEVEL 1 of SLAP /////
	////////////////////////////

	// This group of functions only check for VALIDITY of
	// INDIVIDUAL year/month/day/hour/minute values.
	// They do not check whether the values come together
	// to give a "correct" DateTime object.
	bool isValidDateTimeValues();
	bool isValidYearRange();
	bool isValidMonthRange();
	bool isValidDayRange();
	bool isValidHourRange();
	bool isValidMinuteRange();


	////////////////////////////
	////// LEVEL 2 of SLAP /////
	////////////////////////////

	// This group of functions checks if the
	// individual year/month/day values come
	// together as a valid date format.
	// i.e. DD MM YYYY or DD MM -1
	bool hasYearMonthDay();
	bool hasMonthDay();
	bool hasYear();
	bool hasMonth();
	bool hasDay();

	// This group of functions checks if the
	// individual year/month/day values come
	// together as a valid time format.
	// i.e. HH MM or -1 -1
	bool hasHour();
	bool hasMinute();
	bool isValidTime();

	// Checks if the date (YYYY MM DD) is an actual
	// Gregorian calendar date
	//	Pre: Date is in YYYY MM DD format. Date that is in
	//	-1 MM DD format will not be processed by thos method.
	bool isActualYearMonthDayDate();



public:

	// Constructor
	DateTimeVerification(DateTime dateTimeObject);


	// Does comprehensive checks to the given DateTme object
	// to determine if it satisfies a valid iPlanner calendar
	// format and is an actual calendar date. Valid formats are: 
	//		YYYY DD MM HH MM
	//		YYYY DD MM -1 -1
	//		-1	 DD MM HH MM
	//		-1	 DD MM -1 -1
	bool isValidDateTime();

	bool hasHourMinute();

};

#endif
	// End of segment: C:\Users\SKR\Documents\main\iLogic\DateTimeVerification.h





	/**
	 * origin: C:\Users\SKR\Documents\main\iLogic\ItemVerification.cpp
	 */


#include <exception>
#include <assert.h>
#include "ItemVerification.h"

const string ItemVerification::ITEM_VERIFICATION_EMPTY_STRING = "";
const string ItemVerification::ITEM_VERIFICATION_AVAILABLE_PRIORITIES = "HMLE";  // High, Medium, Low, *Empty*
const string ItemVerification::ITEM_VERIFICATION_AVAILABLE_LABELS = "PMOE";  // Personal, Milestone, Official, *Empty*
const string ItemVerification::ITEM_VERIFICATION_ERROR_INVALID_NAME = "Invalid Name";
const string ItemVerification::ITEM_VERIFICATION_ERROR_INVALID_DESCRIPTION = "Invalid Description";
const string ItemVerification::ITEM_VERIFICATION_ERROR_INVALID_START_DATE_TIME = "Invalid Start Date/Time";
const string ItemVerification::ITEM_VERIFICATION_ERROR_INVALID_END_DATE_TIME = "Invalid End Date/TIME";
const string ItemVerification::ITEM_VERIFICATION_ERROR_SAME_START_END_DATE_TIME = "Start Date/Time same as End Date/Time";
const string ItemVerification::ITEM_VERIFICATION_ERROR_START_DATE_TIME_LATER_THAN_END_DATE_TIME = "Start Date/Time is later than End Date/Time";
const string ItemVerification::ITEM_VERIFICATION_ERROR_INVALID_ID = "Invalid ID";
const string ItemVerification::ITEM_VERIFICATION_ERROR_INVALID_PRIORITY = "Invalid Priority";
const string ItemVerification::ITEM_VERIFICATION_ERROR_INVALID_LABEL = "Invalid Label";

const string ItemVerification::ITEM_VERIFICATION_LOG_VALID_NAME_SUCCESS = "ITEM VERIFICATION:: Valid Name";
const string ItemVerification::ITEM_VERIFICATION_LOG_VALID_NAME_FAILURE = "ITEM VERIFICATION:: Invalid Name";
const string ItemVerification::ITEM_VERIFICATION_LOG_VALID_DESC_SUCCESS = "ITEM VERIFICATION:: Valid Description";
const string ItemVerification::ITEM_VERIFICATION_LOG_VALID_START_TIME = "ITEM VERIFICATION:: Valid Start Time";
const string ItemVerification::ITEM_VERIFICATION_LOG_INVALID_START_TIME = "ITEM VERIFICATION:: Invalid Start Time";
const string ItemVerification::ITEM_VERIFICATION_LOG_VALID_END_TIME = "ITEM VERIFICATION:: Valid End Time";
const string ItemVerification::ITEM_VERIFICATION_LOG_INVALID_END_TIME = "ITEM VERIFICATION:: Invalid End Time";
const string ItemVerification::ITEM_VERIFICATION_LOG_VALID_TIME_FRAME = "ITEM VERIFICATION:: Valid Time Frame";
const string ItemVerification::ITEM_VERIFICATION_LOG_INVALID_TIME_FRAME = "ITEM VERIFICATION:: Invalid Time Frame";
const string ItemVerification::ITEM_VERIFICATION_LOG_VALID_ID_SUCCESS = "ITEM VERIFICATION:: Valid ID";
const string ItemVerification::ITEM_VERIFICATION_LOG_VALID_ID_FAILURE = "ITEM VERIFICATION:: Invalid ID";
const string ItemVerification::ITEM_VERIFICATION_LOG_VALID_PRIORITY_SUCCESS = "ITEM VERIFICATION:: Valid Priority";
const string ItemVerification::ITEM_VERIFICATION_LOG_VALID_PRIORITY_FAILURE = "ITEM VERIFICATION:: Invalid Priority";

const int ItemVerification::ITEM_VERIFICATION_INT_ZERO = 0;

ItemVerification::ItemVerification(Item itemObject, unsigned int nextItemID) {
	_itemObjectToVerify = itemObject;
	_name = _itemObjectToVerify.getItemName();
	_description = _itemObjectToVerify.getDescription();
	_itemID = _itemObjectToVerify.getItemID();
	_startTime = _itemObjectToVerify.getStartTime();
	_endTime = _itemObjectToVerify.getEndTime();
	_priority = _itemObjectToVerify.getPriority();
	_label = _itemObjectToVerify.getLabel();
	_isCompleted = _itemObjectToVerify.getCompletion();
	_nextID = nextItemID;
}

bool ItemVerification::isValidName() {
	string name = _itemObjectToVerify.getItemName();
	if (name == ITEM_VERIFICATION_EMPTY_STRING) {
		_itemVerificationErrors.push_back(ITEM_VERIFICATION_ERROR_INVALID_NAME);
		_itemVerificationLogger.writeToLogFile(ITEM_VERIFICATION_LOG_VALID_NAME_FAILURE);
		assert(!_itemVerificationErrors.empty());
		return false;
	} else {
		_itemVerificationLogger.writeToLogFile(ITEM_VERIFICATION_LOG_VALID_NAME_SUCCESS);
		return true;
	}
}

bool ItemVerification::isValidDescription() {
	_itemVerificationLogger.writeToLogFile(ITEM_VERIFICATION_LOG_VALID_DESC_SUCCESS);
	return true;
}

bool ItemVerification::isValidStartDateTime() {
	DateTime startDateTime = _itemObjectToVerify.getStartTime();
	DateTimeVerification startDateTimeVerification(startDateTime);
	if (startDateTimeVerification.isValidDateTime()) {
		_itemVerificationLogger.writeToLogFile(ITEM_VERIFICATION_LOG_VALID_START_TIME);
		return true;
	} else {
		_itemVerificationErrors.push_back(ITEM_VERIFICATION_ERROR_INVALID_START_DATE_TIME);
		assert(!_itemVerificationErrors.empty());
		_itemVerificationLogger.writeToLogFile(ITEM_VERIFICATION_LOG_INVALID_START_TIME);
		return false;
	}
}

bool ItemVerification::isValidEndDateTime() {
	DateTime endDateTime = _itemObjectToVerify.getEndTime();
	DateTimeVerification endDateTimeVerification(endDateTime);
	if (endDateTimeVerification.isValidDateTime()) {
		_itemVerificationLogger.writeToLogFile(ITEM_VERIFICATION_LOG_VALID_END_TIME);
		return true;
	} else {
		_itemVerificationErrors.push_back(ITEM_VERIFICATION_ERROR_INVALID_END_DATE_TIME);
		assert(!_itemVerificationErrors.empty());
		_itemVerificationLogger.writeToLogFile(ITEM_VERIFICATION_LOG_INVALID_END_TIME);
		return false;
	}
}

bool ItemVerification::isValidTimeFrame() {
	DateTime startDateTime = _itemObjectToVerify.getStartTime();
	DateTime endDateTime = _itemObjectToVerify.getEndTime();
	DateTime emptyDateTime;
	DateTimeVerification startDateTimeVerification(startDateTime);
	DateTimeVerification endDateTimeVerification(endDateTime);
	if (startDateTimeVerification.isValidDateTime() && endDateTimeVerification.isValidDateTime()) {
		if (startDateTimeVerification.hasHourMinute() && endDateTimeVerification.hasHourMinute()) {
			if (startDateTime == endDateTime) {
				_itemVerificationErrors.push_back(ITEM_VERIFICATION_ERROR_SAME_START_END_DATE_TIME);
				assert(!_itemVerificationErrors.empty());
				_itemVerificationLogger.writeToLogFile(ITEM_VERIFICATION_LOG_INVALID_TIME_FRAME);
				return false;
			} else if (startDateTime.isAfter(endDateTime)) {
				_itemVerificationErrors.push_back(ITEM_VERIFICATION_ERROR_START_DATE_TIME_LATER_THAN_END_DATE_TIME);
				assert(!_itemVerificationErrors.empty());
				_itemVerificationLogger.writeToLogFile(ITEM_VERIFICATION_LOG_INVALID_TIME_FRAME);
				return false;
			} else {
				_itemVerificationLogger.writeToLogFile(ITEM_VERIFICATION_LOG_VALID_TIME_FRAME);
				return true;
			}
		} else {
			if (startDateTime == emptyDateTime || endDateTime == emptyDateTime) {
				return true;
			} else if (endDateTime.getYear() > startDateTime.getYear()) {
				return true;
			} else if (endDateTime.getYear() == startDateTime.getYear() && endDateTime.getMonth() > startDateTime.getMonth()) {
				return true;
			} else if (endDateTime.getYear() == startDateTime.getYear() && endDateTime.getMonth() == startDateTime.getMonth() && endDateTime.getDay() >= startDateTime.getDay()) {
				return true;
			} else {
				_itemVerificationErrors.push_back(ITEM_VERIFICATION_ERROR_START_DATE_TIME_LATER_THAN_END_DATE_TIME);
				assert(!_itemVerificationErrors.empty());
				return false;
			}
		}
	} else {
		return false;
	}
}

bool ItemVerification::isValidID() {
	unsigned int itemID = _itemObjectToVerify.getItemID();
	if (itemID <= _nextID) {
		_itemVerificationLogger.writeToLogFile(ITEM_VERIFICATION_LOG_VALID_ID_SUCCESS);
		return true;
	} else {
		_itemVerificationErrors.push_back(ITEM_VERIFICATION_ERROR_INVALID_ID);
		assert(!_itemVerificationErrors.empty());
		_itemVerificationLogger.writeToLogFile(ITEM_VERIFICATION_LOG_VALID_ID_FAILURE);
		return false;
	}
}

bool ItemVerification::isValidPriority() {
	string priorityString;
	char priorityChar = _itemObjectToVerify.getPriority();
	unsigned int priorityFound;
	priorityString.push_back(priorityChar);
	priorityFound = priorityString.find_first_of(ITEM_VERIFICATION_AVAILABLE_PRIORITIES);
	if (priorityFound != string::npos) {
		_itemVerificationLogger.writeToLogFile(ITEM_VERIFICATION_LOG_VALID_PRIORITY_SUCCESS);
		return true;
	} else {
		assert(_priority != 'H' && _priority != 'M' && _priority != 'L' && _priority != 'E');
		_itemVerificationErrors.push_back(ITEM_VERIFICATION_ERROR_INVALID_PRIORITY);
		assert(!_itemVerificationErrors.empty());
		_itemVerificationLogger.writeToLogFile(ITEM_VERIFICATION_LOG_VALID_PRIORITY_FAILURE);
		return false;
	}
}

bool ItemVerification::isValidLabel() {
	string labelString;
	char labelChar = _itemObjectToVerify.getLabel();
	unsigned int labelFound;
	labelString.push_back(labelChar);
	labelFound = labelString.find_first_of(ITEM_VERIFICATION_AVAILABLE_LABELS);
	if (labelFound != string::npos) {
		return true;
	} else {
		assert(_label != 'P' && _label != 'M' && _label != 'O' && _label != 'E');
		_itemVerificationErrors.push_back(ITEM_VERIFICATION_ERROR_INVALID_LABEL);
		assert(!_itemVerificationErrors.empty());
		return false;
	}
}

bool ItemVerification::isValidItem() {

	_itemVerificationErrors.clear();

	bool hasValidName = isValidName();
	bool hasValidDescription = isValidDescription();
	bool hasValidStartDateTime = isValidStartDateTime();
	bool hasValidEndDateTime = isValidEndDateTime();
	bool hasValidTimeFrame = isValidTimeFrame();
	bool hasValidID = isValidID();
	bool hasValidPriority = isValidPriority();
	bool hasValidLabel = isValidLabel();

	if (hasValidName &&
		hasValidDescription &&
		hasValidStartDateTime &&
		hasValidEndDateTime &&
		hasValidTimeFrame &&
		hasValidID &&
		hasValidPriority &&
		hasValidLabel) {
		assert(_name != ITEM_VERIFICATION_EMPTY_STRING);
		assert(_priority == 'H' || _priority == 'M' || _priority == 'L' || _priority == 'E');
		assert(_label == 'P' || _label == 'M' || _label == 'O' || _label == 'E');
		assert(_itemID > ITEM_VERIFICATION_INT_ZERO);
		return true;
	} else {
		return false;
	}
}

list<string> ItemVerification::getItemVerificationErrors() {
	return _itemVerificationErrors;
}
	// End of segment: C:\Users\SKR\Documents\main\iLogic\ItemVerification.cpp





	/**
	 * origin: C:\Users\SKR\Documents\main\iLogic\ItemVerification.h
	 */


#ifndef ITEM_VERIFICATION_H
#define ITEM_VERIFICATION_H

#include <string>
#include <list>
#include <iostream>
#include "DateTimeVerification.h"
#include "..\iStorage\Item.h"
#include "..\iPlanner Log\Log.h"

using namespace std;

class ItemVerification {

private:
	Log _itemVerificationLogger;
	Item _itemObjectToVerify;
	list<string> _itemVerificationErrors;
	unsigned int _nextID;
	string _name;
	string _description;
	unsigned int _itemID;
	DateTime _startTime;
	DateTime _endTime;
	char _priority;
	char _label;
	bool _isCompleted;

	static const string ITEM_VERIFICATION_EMPTY_STRING;
	static const string ITEM_VERIFICATION_AVAILABLE_PRIORITIES;
	static const string ITEM_VERIFICATION_AVAILABLE_LABELS;
	static const string ITEM_VERIFICATION_ERROR_INVALID_NAME;
	static const string ITEM_VERIFICATION_ERROR_INVALID_DESCRIPTION;
	static const string ITEM_VERIFICATION_ERROR_INVALID_START_DATE_TIME;
	static const string ITEM_VERIFICATION_ERROR_INVALID_END_DATE_TIME;
	static const string ITEM_VERIFICATION_ERROR_SAME_START_END_DATE_TIME;
	static const string ITEM_VERIFICATION_ERROR_START_DATE_TIME_LATER_THAN_END_DATE_TIME;
	static const string ITEM_VERIFICATION_ERROR_INVALID_ID;
	static const string ITEM_VERIFICATION_ERROR_INVALID_PRIORITY;
	static const string ITEM_VERIFICATION_ERROR_INVALID_LABEL;

	static const string ITEM_VERIFICATION_LOG_VALID_NAME_SUCCESS;
	static const string ITEM_VERIFICATION_LOG_VALID_NAME_FAILURE;
	static const string ITEM_VERIFICATION_LOG_VALID_DESC_SUCCESS;
	static const string ITEM_VERIFICATION_LOG_VALID_START_TIME;
	static const string ITEM_VERIFICATION_LOG_INVALID_START_TIME;
	static const string ITEM_VERIFICATION_LOG_VALID_END_TIME;
	static const string ITEM_VERIFICATION_LOG_INVALID_END_TIME;
	static const string ITEM_VERIFICATION_LOG_VALID_TIME_FRAME;
	static const string ITEM_VERIFICATION_LOG_INVALID_TIME_FRAME;
	static const string ITEM_VERIFICATION_LOG_VALID_ID_SUCCESS;
	static const string ITEM_VERIFICATION_LOG_VALID_ID_FAILURE;
	static const string ITEM_VERIFICATION_LOG_VALID_PRIORITY_SUCCESS;
	static const string ITEM_VERIFICATION_LOG_VALID_PRIORITY_FAILURE;

	static const int ITEM_VERIFICATION_INT_ZERO;

	// Conducts the validity checks on the individual
	// fields within the item
	bool isValidName();
	bool isValidDescription();
	bool isValidStartDateTime();
	bool isValidEndDateTime();
	bool isValidTimeFrame();
	bool isValidID();
	bool isValidPriority();
	bool isValidLabel();

public:
	ItemVerification(Item itemObject, unsigned int nextItemID);

	// Does comprehensive checks to the given Item object to 
	// determine if it can be considered a valid Item according
	// to iPlanner standards.
	bool isValidItem();

	// Allows retrieval of a list of errors with the given
	// Item object.
	list<string> getItemVerificationErrors();

};

#endif
	// End of segment: C:\Users\SKR\Documents\main\iLogic\ItemVerification.h





	/**
	 * origin: C:\Users\SKR\Documents\main\iStorageTest\StorageTest.cpp
	 */

	TEST_METHOD(ItemTestSetLastUpdate) {
		Item *item1 = new Item(string("Item #1"));
		CTime lastUpdate;
		bool isSameTime = false;

		item1->setItemID(2);
		lastUpdate = CTime::GetCurrentTime();
		isSameTime = (lastUpdate == item1->getLastUpdate());
		Assert::AreEqual(true, isSameTime);

		int time1 = time(0);
		int time2 = time(0);
		while (time2 - time1 < 2) {
			time2 = time(0);
		}

		item1->setDescription(string("edited desc"));
		isSameTime = (lastUpdate == item1->getLastUpdate());
		Assert::AreEqual(false, isSameTime);

		lastUpdate = lastUpdate = CTime::GetCurrentTime();
		isSameTime = (lastUpdate == item1->getLastUpdate());
		Assert::AreEqual(true, isSameTime);
	}
	// End of segment: C:\Users\SKR\Documents\main\iStorageTest\StorageTest.cpp





	/**
	 * origin: C:\Users\SKR\Documents\main\iStorageTest\StorageTest.cpp
	 */

	TEST_METHOD(ItemTestGetLastUpdate) {
		Item *item1 = new Item(string("Item #1"));
		CTime lastUpdate;
		bool isSameTime = false;

		item1->setItemID(2);
		lastUpdate = CTime::GetCurrentTime();
		isSameTime = (lastUpdate == item1->getLastUpdate());
		Assert::AreEqual(true, isSameTime);

		int time1 = time(0);
		int time2 = time(0);
		while (time2 - time1 < 2) {
			time2 = time(0);
		}

		item1->setDescription(string("edited desc"));
		isSameTime = (lastUpdate == item1->getLastUpdate());
		Assert::AreEqual(false, isSameTime);

		lastUpdate = lastUpdate = CTime::GetCurrentTime();
		isSameTime = (lastUpdate == item1->getLastUpdate());
		Assert::AreEqual(true, isSameTime);
	}
	// End of segment: C:\Users\SKR\Documents\main\iStorageTest\StorageTest.cpp





	/**
	 * origin: C:\Users\SKR\Documents\main\iStorageTest\StorageTest.cpp
	 */

	TEST_METHOD(ItemTestDisplayLastUpdatedTime) {
		Item *item1 = new Item(string("Item #1"));
		CTime lastUpdate;
		string lastUpdateAsString;
		ostringstream oss;

		item1->setItemID(1);
		lastUpdate = item1->getLastUpdate();
		oss << setw(4) << lastUpdate.GetYear() << "/";
		oss << setfill('0') << setw(2) << lastUpdate.GetMonth() << "/";
		oss << setfill('0') << setw(2) << lastUpdate.GetDay() << " ";
		oss << setfill('0') << setw(2) << lastUpdate.GetHour() << ":";
		oss << setfill('0') << setw(2) << lastUpdate.GetMinute();

		lastUpdateAsString = oss.str();

		Assert::AreEqual(lastUpdateAsString, item1->displayLastUpdatedTime());

	}
	// End of segment: C:\Users\SKR\Documents\main\iStorageTest\StorageTest.cpp





	/**
	 * origin: C:\Users\SKR\Documents\main\iStorageTest\StorageTest.cpp
	 */

	TEST_METHOD(TestResetDisplaySchedule) {
		Schedule lohPengKimSchedule;
		int scheduleSize;

		scheduleSize = lohPengKimSchedule.resetDisplaySchedule();
		Assert::AreEqual(0, scheduleSize);

		Item *item1;
		item1 = new Item;
		item1->setItemName(string("Pressure student into lunch with me"));
		item1->setLabel('P');
		item1->setPriority('M');
		item1->setStartTime(2015, 6, 21, 13, 00);

		Item *item2;
		item2 = new Item;
		item2->setItemName(string("Lure student to my house"));
		item2->setDescription(string("sleeping pills are in the 2nd drawer"));
		item2->setLabel('P');
		item2->setPriority('H');
		item2->setStartTime(2015, 6, 27, 19, 00);

		Item *item3;
		item3 = new Item;
		item3->setItemName(string("Raise student's grade to A"));
		item3->setLabel('P');
		item3->setPriority('L');
		item3->setEndTime(2015, 7, 24);

		Item *item4;
		item4 = new Item;
		item4->setItemName(string("Buy fake passport and air ticket to Siberia"));
		item4->setLabel('P');
		item4->setPriority('H');
		item4->setEndTime(2015, 8, 20);

		lohPengKimSchedule.addItem(item1);
		lohPengKimSchedule.addItem(item2);
		lohPengKimSchedule.addItem(item3);
		lohPengKimSchedule.addItem(item4);

		scheduleSize = lohPengKimSchedule.resetDisplaySchedule();
		Assert::AreEqual(4, scheduleSize);

		delete item1;
		delete item2;
		delete item3;
		delete item4;
		item1 = NULL;
		item2 = NULL;
		item3 = NULL;
		item4 = NULL;
	}

	TEST_METHOD(TestGetDisplayScheduleSize) {
		Schedule iseGirlsSchedule1;
		int scheduleSize;

		Item *item1;
		item1 = new Item;
		item1->setItemName(string("Lunch with Loh Peng Kim"));
		item1->setLabel('O');
		item1->setPriority('H');
		item1->setStartTime(2015, 6, 21, 13, 00);

		Item *item2;
		item2 = new Item;
		item2->setItemName(string("Dinner at Loh Peng Kim's house :S"));
		item2->setLabel('O');
		item2->setPriority('H');
		item2->setStartTime(2015, 6, 27, 19, 00);

		Item *item3;
		item3 = new Item;
		item3->setItemName(string("Appointment at abortion clinic"));
		item3->setLabel('P');
		item3->setPriority('H');
		item3->setStartTime(2015, 8, 15, 9, 00);
		item3->setEndTime(2015, 8, 15, 12, 00);

		iseGirlsSchedule1.addItem(item1);
		iseGirlsSchedule1.addItem(item2);
		iseGirlsSchedule1.addItem(item3);

		iseGirlsSchedule1.resetDisplaySchedule();
		scheduleSize = iseGirlsSchedule1.getSizeOfDisplaySchedule();
		Assert::AreEqual(3, scheduleSize);

		iseGirlsSchedule1.deleteItemGivenDisplayVectorIndex(1);
		iseGirlsSchedule1.resetDisplaySchedule();
		scheduleSize = iseGirlsSchedule1.getSizeOfDisplaySchedule();
		Assert::AreEqual(2, scheduleSize);

		delete item1;
		delete item2;
		delete item3;
		item1 = NULL;
		item2 = NULL;
		item3 = NULL;

	}

	TEST_METHOD(ScheduleTestClearDisplaySchedule) {
		Schedule scheduleToTestClearDisplaySchedule;
		vector<Item> displayScheduleCopy;

		Item* item1 = new Item(string("Item #1"));
		item1->setItemID(1);

		Item* item2 = new Item(string("Item #2"));
		item2->setItemID(2);

		Item* item3 = new Item(string("Item #3"));
		item3->setItemID(3);

		Item* item4 = new Item(string("Item #4"));
		item4->setItemID(4);

		scheduleToTestClearDisplaySchedule.addItem(item1);
		scheduleToTestClearDisplaySchedule.addItem(item2);
		scheduleToTestClearDisplaySchedule.addItem(item3);
		scheduleToTestClearDisplaySchedule.addItem(item4);

		scheduleToTestClearDisplaySchedule.resetDisplaySchedule();
		displayScheduleCopy = scheduleToTestClearDisplaySchedule.retrieveDisplaySchedule();
		Assert::AreEqual(4, int(displayScheduleCopy.size()));

		scheduleToTestClearDisplaySchedule.clearDisplaySchedule();
		displayScheduleCopy = scheduleToTestClearDisplaySchedule.retrieveDisplaySchedule();
		Assert::AreEqual(0, int(displayScheduleCopy.size()));

		delete item1;
		delete item2;
		delete item3;
		delete item4;

		item1 = NULL;
		item2 = NULL;
		item3 = NULL;
		item4 = NULL;
	}
	// End of segment: C:\Users\SKR\Documents\main\iStorageTest\StorageTest.cpp





	/**
	 * origin: C:\Users\SKR\Documents\main\iStorageTest\StorageTest.cpp
	 */

//	Testing of private function muted.
/*	TEST_METHOD(ScheduleTestIsRelevantDateTime) {
		Schedule relevantDateTimeSchedule;
		bool isRelevantDateTimeAccordingToSchedule;

		Item *noDateTimeItem1 = new Item(string("This is no-DateTime Item #1"));
		noDateTimeItem1->setItemID(1);

		Item *itemWithStartTime1 = new Item(string("This is Item w/ Start Time #1"));
		itemWithStartTime1->setItemID(3);
		itemWithStartTime1->setStartTime(2005, 1, 25, 19, 0);

		Item *itemWithStartTime2 = new Item(string("This is Item w/ Start Time #2"));
		itemWithStartTime2->setItemID(4);
		itemWithStartTime2->setStartTime(2016, 1, 1);

		Item *itemWithEndTime1 = new Item(string("This is Item w/ End Time #1"));
		itemWithEndTime1->setItemID(6);
		itemWithEndTime1->setEndTime(2000, 11, 17, 8, 15);

		Item *itemWithEndTime2 = new Item(string("This is Item w/ End Time #2"));
		itemWithEndTime2->setItemID(7);
		itemWithEndTime2->setEndTime(2020, 1, 19, 20, 15);

		Item *itemWithEndTime3 = new Item(string("This is Item w/ End Time #3"));
		itemWithEndTime3->setItemID(8);
		itemWithEndTime3->setEndTime(2014, 11, 30);

		Item *itemWithEndTime4 = new Item(string("This is Item w/ End Time #4"));
		itemWithEndTime4->setItemID(9);
		itemWithEndTime4->setEndTime(2050, 5, 2, 18, 18);

		Item *itemWithStartAndEndTime1 = new Item(string("This is Item w/ Start & End Time #1 with Start and End in range"));
		itemWithStartAndEndTime1->setItemID(10);
		itemWithStartAndEndTime1->setStartTime(2017, 12, 18, 9, 0);
		itemWithStartAndEndTime1->setEndTime(2018, 11, 21, 7, 0);

		Item *itemWithStartAndEndTime2 = new Item(string("This is Item w/ Start & End Time #2 with Start in range, End out of range"));
		itemWithStartAndEndTime2->setItemID(11);
		itemWithStartAndEndTime2->setStartTime(2007, 12, 8);
		itemWithStartAndEndTime2->setEndTime(2098, 11, 21, 7, 0);

		Item *itemWithStartAndEndTime3 = new Item(string("This is Item w/ Start & End Time #3 with Start out of range, End in range"));
		itemWithStartAndEndTime3->setItemID(12);
		itemWithStartAndEndTime3->setStartTime(1990, 12, 18, 9, 0);
		itemWithStartAndEndTime3->setEndTime(2018, 11, 21);

		Item *itemWithStartAndEndTime4 = new Item(string("This is Item w/ Start & End Time #4 with Start and End OUT of range"));
		itemWithStartAndEndTime4->setItemID(13);
		itemWithStartAndEndTime4->setStartTime(3000, 12, 18, 9, 0);
		itemWithStartAndEndTime4->setEndTime(3012, 11, 21, 7, 0);

		DateTime dateTime1(2000, 1, 1, 0, 0);
		DateTime dateTime2(2016, 12, 30, 23, 59);

		isRelevantDateTimeAccordingToSchedule = relevantDateTimeSchedule.isRelevantDateTime(noDateTimeItem1->getStartTime(), noDateTimeItem1->getEndTime(), dateTime1, dateTime2);
		Assert::AreEqual(false, isRelevantDateTimeAccordingToSchedule);

		isRelevantDateTimeAccordingToSchedule = relevantDateTimeSchedule.isRelevantDateTime(itemWithStartTime1->getStartTime(), itemWithStartTime1->getEndTime(), dateTime1, dateTime2);
		Assert::AreEqual(true, isRelevantDateTimeAccordingToSchedule);

		isRelevantDateTimeAccordingToSchedule = relevantDateTimeSchedule.isRelevantDateTime(itemWithStartTime2->getStartTime(), itemWithStartTime1->getEndTime(), dateTime1, dateTime2);
		Assert::AreEqual(true, isRelevantDateTimeAccordingToSchedule);

		isRelevantDateTimeAccordingToSchedule = relevantDateTimeSchedule.isRelevantDateTime(itemWithEndTime1->getStartTime(), itemWithEndTime1->getEndTime(), dateTime1, dateTime2);
		Assert::AreEqual(true, isRelevantDateTimeAccordingToSchedule);

		isRelevantDateTimeAccordingToSchedule = relevantDateTimeSchedule.isRelevantDateTime(itemWithEndTime2->getStartTime(), itemWithEndTime2->getEndTime(), dateTime1, dateTime2);
		Assert::AreEqual(false, isRelevantDateTimeAccordingToSchedule);

		isRelevantDateTimeAccordingToSchedule = relevantDateTimeSchedule.isRelevantDateTime(itemWithEndTime3->getStartTime(), itemWithEndTime3->getEndTime(), dateTime1, dateTime2);
		Assert::AreEqual(true, isRelevantDateTimeAccordingToSchedule);

		isRelevantDateTimeAccordingToSchedule = relevantDateTimeSchedule.isRelevantDateTime(itemWithStartAndEndTime1->getStartTime(), itemWithStartAndEndTime1->getEndTime(), dateTime1, dateTime2);
		Assert::AreEqual(false, isRelevantDateTimeAccordingToSchedule);

		isRelevantDateTimeAccordingToSchedule = relevantDateTimeSchedule.isRelevantDateTime(itemWithStartAndEndTime2->getStartTime(), itemWithStartAndEndTime2->getEndTime(), dateTime1, dateTime2);
		Assert::AreEqual(true, isRelevantDateTimeAccordingToSchedule);

		isRelevantDateTimeAccordingToSchedule = relevantDateTimeSchedule.isRelevantDateTime(itemWithStartAndEndTime3->getStartTime(), itemWithStartAndEndTime3->getEndTime(), dateTime1, dateTime2);
		Assert::AreEqual(true, isRelevantDateTimeAccordingToSchedule);

		isRelevantDateTimeAccordingToSchedule = relevantDateTimeSchedule.isRelevantDateTime(itemWithStartAndEndTime4->getStartTime(), itemWithStartAndEndTime4->getEndTime(), dateTime1, dateTime2);
		Assert::AreEqual(false, isRelevantDateTimeAccordingToSchedule);

		delete noDateTimeItem1;
		delete itemWithEndTime1;
		delete itemWithEndTime2;
		delete itemWithEndTime3;
		delete itemWithEndTime4;
		delete itemWithStartTime1;
		delete itemWithStartTime2;
		delete itemWithStartAndEndTime1;
		delete itemWithStartAndEndTime2;
		delete itemWithStartAndEndTime3;
		delete itemWithStartAndEndTime4;

		noDateTimeItem1 = NULL;
		itemWithEndTime1 = NULL;
		itemWithEndTime2 = NULL;
		itemWithEndTime3 = NULL;
		itemWithEndTime4 = NULL;
		itemWithStartTime1 = NULL;
		itemWithStartTime2 = NULL;
		itemWithStartAndEndTime1 = NULL;
		itemWithStartAndEndTime2 = NULL;
		itemWithStartAndEndTime3 = NULL;
		itemWithStartAndEndTime4 = NULL;
	}*/

	};

	TEST_CLASS(TEST_FILTER) {
public:

//	Label functionality not implemented in production release
	TEST_METHOD(ScheduleTestFilterDisplayScheduleByLabel) {
		//	Test code here
	}

	TEST_METHOD(ScheduleTestFilterDisplayScheduleByPriority) {
		Schedule prioritySchedule;
		bool isSamePriorityAsDefinedByUser;

		Item *highPriorityItem1 = new Item(string("This is High #1"));
		highPriorityItem1->setItemID(1);
		highPriorityItem1->setPriority('H');

		Item *highPriorityItem2 = new Item(string("This is High #2"));
		highPriorityItem2->setItemID(2);
		highPriorityItem2->setPriority('H');

		Item *highPriorityItem3 = new Item(string("This is High #3"));
		highPriorityItem3->setItemID(3);
		highPriorityItem3->setPriority('H');

		Item *highPriorityItem4 = new Item(string("This is High #4"));
		highPriorityItem4->setItemID(4);
		highPriorityItem4->setPriority('H');

		Item *medPriorityItem1 = new Item(string("This is Medium #1"));
		medPriorityItem1->setItemID(5);
		medPriorityItem1->setPriority('M');

		Item *medPriorityItem2 = new Item(string("This is Medium #2"));
		medPriorityItem2->setItemID(6);
		medPriorityItem2->setPriority('M');

		Item *lowPriorityItem1 = new Item(string("This is Low #1"));
		lowPriorityItem1->setItemID(7);
		lowPriorityItem1->setPriority('L');

		Item *lowPriorityItem2 = new Item(string("This is Low #2"));
		lowPriorityItem2->setItemID(8);
		lowPriorityItem2->setPriority('L');

		Item *lowPriorityItem3 = new Item(string("This is Low #3"));
		lowPriorityItem3->setItemID(9);
		lowPriorityItem3->setPriority('L');

		Item *lowPriorityItem4 = new Item(string("This is Low #4"));
		lowPriorityItem4->setItemID(10);
		lowPriorityItem4->setPriority('L');

		Item *lowPriorityItem5 = new Item(string("This is Low #5"));
		lowPriorityItem5->setItemID(11);
		lowPriorityItem5->setPriority('L');

		prioritySchedule.addItem(highPriorityItem1);
		prioritySchedule.addItem(highPriorityItem2);
		prioritySchedule.addItem(highPriorityItem3);
		prioritySchedule.addItem(highPriorityItem4);
		prioritySchedule.addItem(medPriorityItem1);
		prioritySchedule.addItem(medPriorityItem2);
		prioritySchedule.addItem(lowPriorityItem1);
		prioritySchedule.addItem(lowPriorityItem2);
		prioritySchedule.addItem(lowPriorityItem3);
		prioritySchedule.addItem(lowPriorityItem4);
		prioritySchedule.addItem(lowPriorityItem5);

		prioritySchedule.resetDisplaySchedule();
		Assert::AreEqual(11, int(prioritySchedule.getSizeOfDisplaySchedule()));

		isSamePriorityAsDefinedByUser = prioritySchedule.filterDisplayScheduleByPriority(1, 'H');
		Assert::AreEqual(false, isSamePriorityAsDefinedByUser);
		Assert::AreEqual(11, int(prioritySchedule.getSizeOfDisplaySchedule()));

		prioritySchedule.resetDisplaySchedule();
		isSamePriorityAsDefinedByUser = prioritySchedule.filterDisplayScheduleByPriority(5, 'H');
		Assert::AreEqual(true, isSamePriorityAsDefinedByUser);
		Assert::AreEqual(10, int(prioritySchedule.getSizeOfDisplaySchedule()));

		prioritySchedule.resetDisplaySchedule();
		Assert::AreEqual(11, int(prioritySchedule.getSizeOfDisplaySchedule()));
		isSamePriorityAsDefinedByUser = prioritySchedule.filterDisplayScheduleByPriority(4, 'M');
		Assert::AreEqual(false, isSamePriorityAsDefinedByUser);
		Assert::AreEqual(11, int(prioritySchedule.getSizeOfDisplaySchedule()));
		isSamePriorityAsDefinedByUser = prioritySchedule.filterDisplayScheduleByPriority(10, 'M');
		Assert::AreEqual(true, isSamePriorityAsDefinedByUser);
		Assert::AreEqual(10, int(prioritySchedule.getSizeOfDisplaySchedule()));

		delete highPriorityItem1;
		delete highPriorityItem2;
		delete highPriorityItem3;
		delete highPriorityItem4;
		delete medPriorityItem1;
		delete medPriorityItem2;
		delete lowPriorityItem1;
		delete lowPriorityItem2;
		delete lowPriorityItem3;
		delete lowPriorityItem4;
		delete lowPriorityItem5;

		highPriorityItem1 = NULL;
		highPriorityItem2 = NULL;
		highPriorityItem3 = NULL;
		highPriorityItem4 = NULL;
		medPriorityItem1 = NULL;
		medPriorityItem2 = NULL;
		lowPriorityItem1 = NULL;
		lowPriorityItem2 = NULL;
		lowPriorityItem3 = NULL;
		lowPriorityItem4 = NULL;
		lowPriorityItem5 = NULL;
	}

	TEST_METHOD(ScheduleTestFilterDisplayScheduleByCompletion) {
		Schedule completionTestSchedule;
		bool isSameCompletionAsSpecifiedByUser;

		Item *completedItem1 = new Item(string("This is Completed #1"));
		completedItem1->setItemID(1);
		completedItem1->setCompletion(true);

		Item *completedItem2 = new Item(string("This is Completed #2"));
		completedItem2->setItemID(2);
		completedItem2->setCompletion(true);

		Item *completedItem3 = new Item(string("This is Completed #3"));
		completedItem3->setItemID(3);
		completedItem3->setCompletion(true);

		Item *completedItem4 = new Item(string("This is Completed #4"));
		completedItem4->setItemID(4);
		completedItem4->setCompletion(true);

		Item *uncompletedItem1 = new Item(string("This is Uncompleted #1"));
		uncompletedItem1->setItemID(5);
		uncompletedItem1->setCompletion(false);

		Item *uncompletedItem2 = new Item(string("This is Uncompleted #2"));
		uncompletedItem2->setItemID(6);
		uncompletedItem2->setCompletion(false);

		completionTestSchedule.addItem(completedItem1);
		completionTestSchedule.addItem(completedItem2);
		completionTestSchedule.addItem(completedItem3);
		completionTestSchedule.addItem(completedItem4);
		completionTestSchedule.addItem(uncompletedItem1);
		completionTestSchedule.addItem(uncompletedItem2);

		completionTestSchedule.resetDisplaySchedule();
		Assert::AreEqual(6, int(completionTestSchedule.getSizeOfDisplaySchedule()));

		isSameCompletionAsSpecifiedByUser = completionTestSchedule.filterDisplayScheduleByCompletion(0, false);
		Assert::AreEqual(true, isSameCompletionAsSpecifiedByUser);
		Assert::AreEqual(5, int(completionTestSchedule.getSizeOfDisplaySchedule()));

		completionTestSchedule.resetDisplaySchedule();
		Assert::AreEqual(6, int(completionTestSchedule.getSizeOfDisplaySchedule()));

		isSameCompletionAsSpecifiedByUser = completionTestSchedule.filterDisplayScheduleByCompletion(5, false);
		Assert::AreEqual(false, isSameCompletionAsSpecifiedByUser);
		Assert::AreEqual(6, int(completionTestSchedule.getSizeOfDisplaySchedule()));
		isSameCompletionAsSpecifiedByUser = completionTestSchedule.filterDisplayScheduleByCompletion(3, true);
		Assert::AreEqual(false, isSameCompletionAsSpecifiedByUser);
		Assert::AreEqual(6, int(completionTestSchedule.getSizeOfDisplaySchedule()));
		isSameCompletionAsSpecifiedByUser = completionTestSchedule.filterDisplayScheduleByCompletion(2, false);
		Assert::AreEqual(true, isSameCompletionAsSpecifiedByUser);
		Assert::AreEqual(5, int(completionTestSchedule.getSizeOfDisplaySchedule()));

		delete completedItem1;
		delete completedItem2;
		delete completedItem3;
		delete completedItem4;
		delete uncompletedItem1;
		delete uncompletedItem2;

		completedItem1 = NULL;
		completedItem2 = NULL;
		completedItem3 = NULL;
		completedItem4 = NULL;
		uncompletedItem1 = NULL;
		uncompletedItem2 = NULL;
	}

	TEST_METHOD(ScheduleTestFilterDisplayScheduleByDateTime) {
		Schedule dateTimeSchedule;
		bool isRelevantDateTime;

		Item *noDateTimeItem1 = new Item(string("This is no-DateTime Item #1"));
		noDateTimeItem1->setItemID(1);

		Item *noDateTimeItem2 = new Item(string("This is no-DateTime Item #2"));
		noDateTimeItem2->setItemID(2);

		Item *itemWithStartTime1 = new Item(string("This is Item w/ Start Time #1"));
		itemWithStartTime1->setItemID(3);
		itemWithStartTime1->setStartTime(2009, 1, 25, 19, 0);

		Item *itemWithStartTime2 = new Item(string("This is Item w/ Start Time #2"));
		itemWithStartTime2->setItemID(4);
		itemWithStartTime2->setStartTime(2015, 11, 2, 7, 0);

		Item *itemWithStartTime3 = new Item(string("This is Item w/ Start Time #3"));
		itemWithStartTime3->setItemID(5);
		itemWithStartTime3->setStartTime(2014, 4, 17);

		Item *itemWithEndTime1 = new Item(string("This is Item w/ End Time #1"));
		itemWithEndTime1->setItemID(6);
		itemWithEndTime1->setEndTime(2008, 11, 17, 8, 15);

		Item *itemWithEndTime2 = new Item(string("This is Item w/ End Time #2"));
		itemWithEndTime2->setItemID(7);
		itemWithEndTime2->setEndTime(2099, 1, 19, 20, 15);

		Item *itemWithEndTime3 = new Item(string("This is Item w/ End Time #3"));
		itemWithEndTime3->setItemID(8);
		itemWithEndTime3->setEndTime(2008, 11, 30);

		Item *itemWithEndTime4 = new Item(string("This is Item w/ End Time #4"));
		itemWithEndTime4->setItemID(9);
		itemWithEndTime4->setEndTime(2014, 5, 2, 18, 18);

		Item *itemWithStartAndEndTime1 = new Item(string("This is Item w/ Start & End Time #1 with Start and End in range"));
		itemWithStartAndEndTime1->setItemID(10);
		itemWithStartAndEndTime1->setStartTime(2017, 12, 18, 9, 0);
		itemWithStartAndEndTime1->setEndTime(2018, 11, 21, 7, 0);

		Item *itemWithStartAndEndTime2 = new Item(string("This is Item w/ Start & End Time #2 with Start in range, End out of range"));
		itemWithStartAndEndTime2->setItemID(11);
		itemWithStartAndEndTime2->setStartTime(2017, 12, 18, 9, 0);
		itemWithStartAndEndTime2->setEndTime(2098, 11, 21, 7, 0);

		Item *itemWithStartAndEndTime3 = new Item(string("This is Item w/ Start & End Time #3 with Start out of range, End in range"));
		itemWithStartAndEndTime3->setItemID(12);
		itemWithStartAndEndTime3->setStartTime(1990, 12, 18, 9, 0);
		itemWithStartAndEndTime3->setEndTime(2018, 11, 21, 7, 0);

		Item *itemWithStartAndEndTime4 = new Item(string("This is Item w/ Start & End Time #4 with Start and End OUT of range"));
		itemWithStartAndEndTime4->setItemID(13);
		itemWithStartAndEndTime4->setStartTime(3000, 12, 18, 9, 0);
		itemWithStartAndEndTime4->setEndTime(3012, 11, 21, 7, 0);

		dateTimeSchedule.addItem(noDateTimeItem1);
		dateTimeSchedule.addItem(noDateTimeItem2);
		dateTimeSchedule.addItem(itemWithStartTime1);
		dateTimeSchedule.addItem(itemWithStartTime2);
		dateTimeSchedule.addItem(itemWithStartTime3);
		dateTimeSchedule.addItem(itemWithEndTime1);
		dateTimeSchedule.addItem(itemWithEndTime2);
		dateTimeSchedule.addItem(itemWithEndTime3);
		dateTimeSchedule.addItem(itemWithEndTime4);
		dateTimeSchedule.addItem(itemWithStartAndEndTime1);
		dateTimeSchedule.addItem(itemWithStartAndEndTime2);
		dateTimeSchedule.addItem(itemWithStartAndEndTime3);
		dateTimeSchedule.addItem(itemWithStartAndEndTime4);

		dateTimeSchedule.resetDisplaySchedule();
		Assert::AreEqual(13, int(dateTimeSchedule.getSizeOfDisplaySchedule()));
		isRelevantDateTime = dateTimeSchedule.filterDisplayScheduleByDateTime(0, DateTime(2000, 1, 1, 0, 0), DateTime(2020, 12, 30, 23, 59));
		Assert::AreEqual(true, isRelevantDateTime);
		Assert::AreEqual(12, int(dateTimeSchedule.getSizeOfDisplaySchedule()));

		dateTimeSchedule.resetDisplaySchedule();
		Assert::AreEqual(13, int(dateTimeSchedule.getSizeOfDisplaySchedule()));
		isRelevantDateTime = dateTimeSchedule.filterDisplayScheduleByDateTime(2, DateTime(2000, 1, 1, 0, 0), DateTime(2020, 12, 30, 23, 59));
		Assert::AreEqual(false, isRelevantDateTime);
		Assert::AreEqual(13, int(dateTimeSchedule.getSizeOfDisplaySchedule()));

		dateTimeSchedule.resetDisplaySchedule();
		Assert::AreEqual(13, int(dateTimeSchedule.getSizeOfDisplaySchedule()));
		isRelevantDateTime = dateTimeSchedule.filterDisplayScheduleByDateTime(6, DateTime(2000, 1, 1, 0, 0), DateTime(2020, 12, 30, 23, 59));
		Assert::AreEqual(true, isRelevantDateTime);
		Assert::AreEqual(12, int(dateTimeSchedule.getSizeOfDisplaySchedule()));

		dateTimeSchedule.resetDisplaySchedule();
		Assert::AreEqual(13, int(dateTimeSchedule.getSizeOfDisplaySchedule()));
		isRelevantDateTime = dateTimeSchedule.filterDisplayScheduleByDateTime(9, DateTime(2000, 1, 1, 0, 0), DateTime(2020, 12, 30, 23, 59));
		Assert::AreEqual(false, isRelevantDateTime);
		Assert::AreEqual(13, int(dateTimeSchedule.getSizeOfDisplaySchedule()));
		isRelevantDateTime = dateTimeSchedule.filterDisplayScheduleByDateTime(10, DateTime(2000, 1, 1, 0, 0), DateTime(2020, 12, 30, 23, 59));
		Assert::AreEqual(false, isRelevantDateTime);
		Assert::AreEqual(13, int(dateTimeSchedule.getSizeOfDisplaySchedule()));
		isRelevantDateTime = dateTimeSchedule.filterDisplayScheduleByDateTime(12, DateTime(2000, 1, 1, 0, 0), DateTime(2020, 12, 30, 23, 59));
		Assert::AreEqual(true, isRelevantDateTime);
		Assert::AreEqual(12, int(dateTimeSchedule.getSizeOfDisplaySchedule()));

		delete noDateTimeItem1;
		delete noDateTimeItem2;
		delete itemWithEndTime1;
		delete itemWithEndTime2;
		delete itemWithEndTime3;
		delete itemWithEndTime4;
		delete itemWithStartTime1;
		delete itemWithStartTime2;
		delete itemWithStartTime3;
		delete itemWithStartAndEndTime1;
		delete itemWithStartAndEndTime2;
		delete itemWithStartAndEndTime3;
		delete itemWithStartAndEndTime4;

		noDateTimeItem1 = NULL;
		noDateTimeItem2 = NULL;
		itemWithEndTime1 = NULL;
		itemWithEndTime2 = NULL;
		itemWithEndTime3 = NULL;
		itemWithEndTime4 = NULL;
		itemWithStartTime1 = NULL;
		itemWithStartTime2 = NULL;
		itemWithStartTime3 = NULL;
		itemWithStartAndEndTime1 = NULL;
		itemWithStartAndEndTime2 = NULL;
		itemWithStartAndEndTime3 = NULL;
		itemWithStartAndEndTime4 = NULL;
	}

	TEST_METHOD(ScheduleTestFilterDisplayScheduleByKeyword) {
		Schedule keywordSchedule;
		bool hasKeyword;

		Item *withKeyword1 = new Item(string("Has keyword wahlau eh"));
		withKeyword1->setItemID(1);

		Item *withKeyword2 = new Item(string("Has keyword in description"));
		withKeyword2->setItemID(2);
		withKeyword2->setDescription(string("the keyword wahLau eH is here"));

		Item* withoutKeyword1 = new Item(string("No keyword in here wah eh"));
		withoutKeyword1->setItemID(3);

		Item* withoutKeyword2 = new Item(string("No sign of keyword here either"));
		withoutKeyword2->setItemID(4);
		withoutKeyword2->setDescription(string("wahskdjlaw eh"));

		keywordSchedule.addItem(withKeyword1);
		keywordSchedule.addItem(withKeyword2);
		keywordSchedule.addItem(withoutKeyword1);
		keywordSchedule.addItem(withoutKeyword2);

		keywordSchedule.resetDisplaySchedule();
		Assert::AreEqual(4, int(keywordSchedule.getSizeOfDisplaySchedule()));
		hasKeyword = keywordSchedule.filterDisplayScheduleByKeyword(0, string("wahlau eh"));
		Assert::AreEqual(4, int(keywordSchedule.getSizeOfDisplaySchedule()));
		Assert::AreEqual(false, hasKeyword);
		hasKeyword = keywordSchedule.filterDisplayScheduleByKeyword(1, string("wahlau eh"));
		Assert::AreEqual(4, int(keywordSchedule.getSizeOfDisplaySchedule()));
		Assert::AreEqual(false, hasKeyword);
		hasKeyword = keywordSchedule.filterDisplayScheduleByKeyword(2, string("wahlau eh"));
		Assert::AreEqual(3, int(keywordSchedule.getSizeOfDisplaySchedule()));
		Assert::AreEqual(true, hasKeyword);
		hasKeyword = keywordSchedule.filterDisplayScheduleByKeyword(2, string("wahlau eh"));
		Assert::AreEqual(2, int(keywordSchedule.getSizeOfDisplaySchedule()));
		Assert::AreEqual(true, hasKeyword);

		delete withKeyword1;
		delete withKeyword2;
		delete withoutKeyword1;
		delete withoutKeyword2;

		withKeyword1 = NULL;
		withKeyword2 = NULL;
		withoutKeyword1 = NULL;
		withoutKeyword2 = NULL;
	}

//	Label functionality not implemented in production release
	TEST_METHOD(ScheduleTestRetrieveDisplayScheduleFilteredByLabel) {
		//	Test code here
	}

	TEST_METHOD(ScheduleTestRetrieveDisplayScheduleFilteredByPriority) {
		Schedule prioritySchedule;
		vector<Item> filteredVectorByPriority;

		Item *highPriorityItem1 = new Item(string("This is High #1"));
		highPriorityItem1->setItemID(1);
		highPriorityItem1->setPriority('H');

		Item *highPriorityItem2 = new Item(string("This is High #2"));
		highPriorityItem2->setItemID(2);
		highPriorityItem2->setPriority('H');

		Item *highPriorityItem3 = new Item(string("This is High #3"));
		highPriorityItem3->setItemID(3);
		highPriorityItem3->setPriority('H');

		Item *highPriorityItem4 = new Item(string("This is High #4"));
		highPriorityItem4->setItemID(4);
		highPriorityItem4->setPriority('H');

		Item *medPriorityItem1 = new Item(string("This is Medium #1"));
		medPriorityItem1->setItemID(5);
		medPriorityItem1->setPriority('M');

		Item *medPriorityItem2 = new Item(string("This is Medium #2"));
		medPriorityItem2->setItemID(6);
		medPriorityItem2->setPriority('M');

		Item *lowPriorityItem1 = new Item(string("This is Low #1"));
		lowPriorityItem1->setItemID(7);
		lowPriorityItem1->setPriority('L');

		Item *lowPriorityItem2 = new Item(string("This is Low #2"));
		lowPriorityItem2->setItemID(8);
		lowPriorityItem2->setPriority('L');

		Item *lowPriorityItem3 = new Item(string("This is Low #3"));
		lowPriorityItem3->setItemID(9);
		lowPriorityItem3->setPriority('L');

		Item *lowPriorityItem4 = new Item(string("This is Low #4"));
		lowPriorityItem4->setItemID(10);
		lowPriorityItem4->setPriority('L');

		Item *lowPriorityItem5 = new Item(string("This is Low #5"));
		lowPriorityItem5->setItemID(11);
		lowPriorityItem5->setPriority('L');

		prioritySchedule.addItem(highPriorityItem1);
		prioritySchedule.addItem(highPriorityItem2);
		prioritySchedule.addItem(highPriorityItem3);
		prioritySchedule.addItem(highPriorityItem4);
		prioritySchedule.addItem(medPriorityItem1);
		prioritySchedule.addItem(medPriorityItem2);
		prioritySchedule.addItem(lowPriorityItem1);
		prioritySchedule.addItem(lowPriorityItem2);
		prioritySchedule.addItem(lowPriorityItem3);
		prioritySchedule.addItem(lowPriorityItem4);
		prioritySchedule.addItem(lowPriorityItem5);

		prioritySchedule.resetDisplaySchedule();
		filteredVectorByPriority = prioritySchedule.retrieveDisplayScheduleFilteredByPriority('H');
		Assert::AreEqual(4, int(filteredVectorByPriority.size()));

		prioritySchedule.resetDisplaySchedule();
		filteredVectorByPriority = prioritySchedule.retrieveDisplayScheduleFilteredByPriority('L');
		Assert::AreEqual(5, int(filteredVectorByPriority.size()));

		prioritySchedule.resetDisplaySchedule();
		filteredVectorByPriority = prioritySchedule.retrieveDisplayScheduleFilteredByPriority('M');
		Assert::AreEqual(2, int(filteredVectorByPriority.size()));

		delete highPriorityItem1;
		delete highPriorityItem2;
		delete highPriorityItem3;
		delete highPriorityItem4;
		delete medPriorityItem1;
		delete medPriorityItem2;
		delete lowPriorityItem1;
		delete lowPriorityItem2;
		delete lowPriorityItem3;
		delete lowPriorityItem4;
		delete lowPriorityItem5;

		highPriorityItem1 = NULL;
		highPriorityItem2 = NULL;
		highPriorityItem3 = NULL;
		highPriorityItem4 = NULL;
		medPriorityItem1 = NULL;
		medPriorityItem2 = NULL;
		lowPriorityItem1 = NULL;
		lowPriorityItem2 = NULL;
		lowPriorityItem3 = NULL;
		lowPriorityItem4 = NULL;
		lowPriorityItem5 = NULL;
	}

	TEST_METHOD(ScheduleTestRetrieveDisplayScheduleFilteredByCompletion) {
		Schedule completionTestSchedule;
		vector<Item> filteredVectorByCompletion;

		Item *completedItem1 = new Item(string("This is Completed #1"));
		completedItem1->setItemID(1);
		completedItem1->setCompletion(true);

		Item *completedItem2 = new Item(string("This is Completed #2"));
		completedItem2->setItemID(2);
		completedItem2->setCompletion(true);

		Item *completedItem3 = new Item(string("This is Completed #3"));
		completedItem3->setItemID(3);
		completedItem3->setCompletion(true);

		Item *completedItem4 = new Item(string("This is Completed #4"));
		completedItem4->setItemID(4);
		completedItem4->setCompletion(true);

		Item *uncompletedItem1 = new Item(string("This is Uncompleted #1"));
		uncompletedItem1->setItemID(5);
		uncompletedItem1->setCompletion(false);

		Item *uncompletedItem2 = new Item(string("This is Uncompleted #2"));
		uncompletedItem2->setItemID(6);
		uncompletedItem2->setCompletion(false);

		completionTestSchedule.addItem(completedItem1);
		completionTestSchedule.addItem(completedItem2);
		completionTestSchedule.addItem(completedItem3);
		completionTestSchedule.addItem(completedItem4);
		completionTestSchedule.addItem(uncompletedItem1);
		completionTestSchedule.addItem(uncompletedItem2);

		filteredVectorByCompletion = completionTestSchedule.retrieveDisplayScheduleFilteredByCompletion(true);
		Assert::AreEqual(0, int(filteredVectorByCompletion.size()));

		completionTestSchedule.resetDisplaySchedule();
		Assert::AreEqual(6, int(completionTestSchedule.getSizeOfDisplaySchedule()));

		filteredVectorByCompletion = completionTestSchedule.retrieveDisplayScheduleFilteredByCompletion(true);
		Assert::AreEqual(4, int(filteredVectorByCompletion.size()));

		completionTestSchedule.resetDisplaySchedule();
		filteredVectorByCompletion = completionTestSchedule.retrieveDisplayScheduleFilteredByCompletion(false);
		Assert::AreEqual(2, int(filteredVectorByCompletion.size()));

		delete completedItem1;
		delete completedItem2;
		delete completedItem3;
		delete completedItem4;
		delete uncompletedItem1;
		delete uncompletedItem2;

		completedItem1 = NULL;
		completedItem2 = NULL;
		completedItem3 = NULL;
		completedItem4 = NULL;
		uncompletedItem1 = NULL;
		uncompletedItem2 = NULL;
	}

	TEST_METHOD(ScheduleTestRetrieveDisplayScheduleFilteredByDateTime) {
		Schedule dateTimeSchedule;
		vector<Item> filteredVectorByDateTime;

		Item *noDateTimeItem1 = new Item(string("This is no-DateTime Item #1"));
		noDateTimeItem1->setItemID(1);

		Item *noDateTimeItem2 = new Item(string("This is no-DateTime Item #2"));
		noDateTimeItem2->setItemID(2);

		Item *itemWithStartTime1 = new Item(string("This is Item w/ Start Time #1"));
		itemWithStartTime1->setItemID(3);
		itemWithStartTime1->setStartTime(2005, 1, 25, 19, 0);

		Item *itemWithStartTime2 = new Item(string("This is Item w/ Start Time #2"));
		itemWithStartTime2->setItemID(4);
		itemWithStartTime2->setStartTime(2010, 11, 2, 7, 0);

		Item *itemWithStartTime3 = new Item(string("This is Item w/ Start Time #3"));
		itemWithStartTime3->setItemID(5);
		itemWithStartTime3->setStartTime(2015, 4, 17);

		Item *itemWithEndTime1 = new Item(string("This is Item w/ End Time #1"));
		itemWithEndTime1->setItemID(6);
		itemWithEndTime1->setEndTime(2000, 11, 17, 8, 15);

		Item *itemWithEndTime2 = new Item(string("This is Item w/ End Time #2"));
		itemWithEndTime2->setItemID(7);
		itemWithEndTime2->setEndTime(2020, 1, 19, 20, 15);

		Item *itemWithEndTime3 = new Item(string("This is Item w/ End Time #3"));
		itemWithEndTime3->setItemID(8);
		itemWithEndTime3->setEndTime(2025, 11, 30);

		Item *itemWithEndTime4 = new Item(string("This is Item w/ End Time #4"));
		itemWithEndTime4->setItemID(9);
		itemWithEndTime4->setEndTime(2050, 5, 2, 18, 18);

		Item *itemWithStartAndEndTime1 = new Item(string("This is Item w/ Start & End Time #1 with Start and End in range"));
		itemWithStartAndEndTime1->setItemID(10);
		itemWithStartAndEndTime1->setStartTime(2017, 12, 18, 9, 0);
		itemWithStartAndEndTime1->setEndTime(2018, 11, 21, 7, 0);

		Item *itemWithStartAndEndTime2 = new Item(string("This is Item w/ Start & End Time #2 with Start in range, End out of range"));
		itemWithStartAndEndTime2->setItemID(11);
		itemWithStartAndEndTime2->setStartTime(2017, 12, 18, 9, 0);
		itemWithStartAndEndTime2->setEndTime(2098, 11, 21, 7, 0);

		Item *itemWithStartAndEndTime3 = new Item(string("This is Item w/ Start & End Time #3 with Start out of range, End in range"));
		itemWithStartAndEndTime3->setItemID(12);
		itemWithStartAndEndTime3->setStartTime(1990, 12, 18, 9, 0);
		itemWithStartAndEndTime3->setEndTime(2018, 11, 21, 7, 0);

		Item *itemWithStartAndEndTime4 = new Item(string("This is Item w/ Start & End Time #4 with Start and End OUT of range"));
		itemWithStartAndEndTime4->setItemID(13);
		itemWithStartAndEndTime4->setStartTime(3000, 12, 18, 9, 0);
		itemWithStartAndEndTime4->setEndTime(3012, 11, 21, 7, 0);

		dateTimeSchedule.addItem(noDateTimeItem1);
		dateTimeSchedule.addItem(noDateTimeItem2);
		dateTimeSchedule.addItem(itemWithStartTime1);
		dateTimeSchedule.addItem(itemWithStartTime2);
		dateTimeSchedule.addItem(itemWithStartTime3);
		dateTimeSchedule.addItem(itemWithEndTime1);
		dateTimeSchedule.addItem(itemWithEndTime2);
		dateTimeSchedule.addItem(itemWithEndTime3);
		dateTimeSchedule.addItem(itemWithEndTime4);
		dateTimeSchedule.addItem(itemWithStartAndEndTime1);
		dateTimeSchedule.addItem(itemWithStartAndEndTime2);
		dateTimeSchedule.addItem(itemWithStartAndEndTime3);
		dateTimeSchedule.addItem(itemWithStartAndEndTime4);

		dateTimeSchedule.resetDisplaySchedule();
		Assert::AreEqual(13, int(dateTimeSchedule.getSizeOfDisplaySchedule()));

		filteredVectorByDateTime = dateTimeSchedule.retrieveDisplayScheduleFilteredByDateTime(DateTime(2000, 1, 1, 0, 0), DateTime(2010, 12, 30, 23, 59));
		Assert::AreEqual(4, int(filteredVectorByDateTime.size()));
		Assert::AreEqual(3, int(filteredVectorByDateTime[0].getItemID()));
		Assert::AreEqual(4, int(filteredVectorByDateTime[1].getItemID()));
		Assert::AreEqual(6, int(filteredVectorByDateTime[2].getItemID()));
		Assert::AreEqual(12, int(filteredVectorByDateTime[3].getItemID()));

		// Boundary Case: itemWithStartTime3 starts on 2015/4/17 -1:-1, is not within range
		dateTimeSchedule.resetDisplaySchedule();
		filteredVectorByDateTime = dateTimeSchedule.retrieveDisplayScheduleFilteredByDateTime(DateTime(2015, 4, 17, 0, 0), DateTime(2017, 12, 18, 9, 0));
		Assert::AreEqual(3, int(filteredVectorByDateTime.size()));
		Assert::AreEqual(10, int(filteredVectorByDateTime[0].getItemID()));
		Assert::AreEqual(11, int(filteredVectorByDateTime[1].getItemID()));
		Assert::AreEqual(12, int(filteredVectorByDateTime[2].getItemID()));

		dateTimeSchedule.resetDisplaySchedule();
		filteredVectorByDateTime = dateTimeSchedule.retrieveDisplayScheduleFilteredByDateTime(DateTime(2050, 5, 2, 18, 18), DateTime(3013, 12, 30, 23, 59));
		Assert::AreEqual(3, int(filteredVectorByDateTime.size()));
		Assert::AreEqual(9, int(filteredVectorByDateTime[0].getItemID()));
		Assert::AreEqual(11, int(filteredVectorByDateTime[1].getItemID()));
		Assert::AreEqual(13, int(filteredVectorByDateTime[2].getItemID()));

		delete noDateTimeItem1;
		delete noDateTimeItem2;
		delete itemWithEndTime1;
		delete itemWithEndTime2;
		delete itemWithEndTime3;
		delete itemWithEndTime4;
		delete itemWithStartTime1;
		delete itemWithStartTime2;
		delete itemWithStartTime3;
		delete itemWithStartAndEndTime1;
		delete itemWithStartAndEndTime2;
		delete itemWithStartAndEndTime3;
		delete itemWithStartAndEndTime4;

		noDateTimeItem1 = NULL;
		noDateTimeItem2 = NULL;
		itemWithEndTime1 = NULL;
		itemWithEndTime2 = NULL;
		itemWithEndTime3 = NULL;
		itemWithEndTime4 = NULL;
		itemWithStartTime1 = NULL;
		itemWithStartTime2 = NULL;
		itemWithStartTime3 = NULL;
		itemWithStartAndEndTime1 = NULL;
		itemWithStartAndEndTime2 = NULL;
		itemWithStartAndEndTime3 = NULL;
		itemWithStartAndEndTime4 = NULL;
	}

	TEST_METHOD(ScheduleTestRetrieveDisplayScheduleFilteredByKeyword) {
		Schedule keywordSchedule;
		vector<Item> filteredVectorByKeyword;

		Item *withKeyword1 = new Item(string("Has keyword wahlau eh"));
		withKeyword1->setItemID(1);

		Item *withKeyword2 = new Item(string("Has keyword in description"));
		withKeyword2->setItemID(2);
		withKeyword2->setDescription(string("the keyword wahLau eH is here"));

		Item *withKeyword3 = new Item(string("Has keyword in description"));
		withKeyword3->setItemID(3);
		withKeyword3->setDescription(string("HAHAHAHAHEHEHEWWWWAHLAU EHHHHHHHHH"));

		Item* withoutKeyword1 = new Item(string("No keyword in here wah eh"));
		withoutKeyword1->setItemID(4);

		Item* withoutKeyword2 = new Item(string("No sign of keyword here either"));
		withoutKeyword2->setItemID(5);
		withoutKeyword2->setDescription(string("whaskdjlaw eh"));

		keywordSchedule.addItem(withKeyword1);
		keywordSchedule.addItem(withKeyword2);
		keywordSchedule.addItem(withKeyword3);
		keywordSchedule.addItem(withoutKeyword1);
		keywordSchedule.addItem(withoutKeyword2);

		keywordSchedule.resetDisplaySchedule();
		Assert::AreEqual(5, int(keywordSchedule.getSizeOfDisplaySchedule()));

		filteredVectorByKeyword = keywordSchedule.retrieveDisplayScheduleFilteredByKeyword(string("wahlau eh"));
		Assert::AreEqual(3, int(filteredVectorByKeyword.size()));
		Assert::AreEqual(1, int(filteredVectorByKeyword[0].getItemID()));
		Assert::AreEqual(2, int(filteredVectorByKeyword[1].getItemID()));
		Assert::AreEqual(3, int(filteredVectorByKeyword[2].getItemID()));

		keywordSchedule.resetDisplaySchedule();
		filteredVectorByKeyword = keywordSchedule.retrieveDisplayScheduleFilteredByKeyword(string("Ha"));
		Assert::AreEqual(4, int(filteredVectorByKeyword.size()));
		Assert::AreEqual(1, int(filteredVectorByKeyword[0].getItemID()));
		Assert::AreEqual(2, int(filteredVectorByKeyword[1].getItemID()));
		Assert::AreEqual(3, int(filteredVectorByKeyword[2].getItemID()));
		Assert::AreEqual(5, int(filteredVectorByKeyword[3].getItemID()));

		delete withKeyword1;
		delete withKeyword2;
		delete withKeyword3;
		delete withoutKeyword1;
		delete withoutKeyword2;

		withKeyword1 = NULL;
		withKeyword2 = NULL;
		withKeyword3 = NULL;
		withoutKeyword1 = NULL;
		withoutKeyword2 = NULL;
	}

	};

	TEST_CLASS(TEST_SORT) {
public:
	TEST_METHOD(TestSortByPriority) {
		Schedule wonderDiet;
		vector<Item> displaySchedule;

		Item *day1 = new Item(string("Eat nothing but bananas"));
		day1->setItemID(1);
		day1->setDescription(string("This is not going to end well"));
		day1->setLabel('M');
		day1->setPriority('H');
		day1->setStartTime(2015, 4, 2);

		Item *day2 = new Item(string("Eat nothing but jackfruit"));
		day2->setItemID(2);
		day2->setDescription(string("I don't feel too good now..."));
		day2->setLabel('M');
		day2->setPriority('L');
		day2->setStartTime(2015, 4, 3);

		Item *day3 = new Item(string("Buy more toilet paper!"));
		day3->setItemID(3);
		day3->setDescription(string("I can't even sit properly"));
		day3->setLabel('O');
		day3->setPriority('H');
		day3->setStartTime(2015, 4, 4);

		Item *day4 = new Item(string("Take MC, eat hemorrhoid medication"));
		day4->setItemID(4);
		day4->setLabel('P');
		day4->setPriority('M');
		day4->setStartTime(2015, 4, 6);

		Item *day5 = new Item(string("Colon cleansing appointment"));
		day5->setItemID(5);
		day5->setDescription(string("What did I do to myself"));
		day5->setLabel('O');
		day5->setPriority('L');
		day5->setStartTime(2015, 4, 7);

		Item *day6 = new Item(string("BBQ Buffet"));
		day6->setItemID(6);
		day6->setDescription(string("Meat is love, meat is life"));
		day6->setLabel('O');
		day6->setPriority('H');
		day6->setStartTime(2015, 4, 8);

		wonderDiet.addItem(day1);
		wonderDiet.addItem(day2);
		wonderDiet.addItem(day3);
		wonderDiet.addItem(day4);
		wonderDiet.addItem(day5);
		wonderDiet.addItem(day6);

		wonderDiet.resetDisplaySchedule();
		wonderDiet.retrieveDisplayScheduleByDate();
		displaySchedule = wonderDiet.retrieveDisplayScheduleByPriority();

		Assert::AreEqual(6, int(displaySchedule.size()));
		Assert::AreEqual(1, int(displaySchedule[0].getItemID()));
		Assert::AreEqual(3, int(displaySchedule[1].getItemID()));
		Assert::AreEqual(6, int(displaySchedule[2].getItemID()));
		Assert::AreEqual(4, int(displaySchedule[3].getItemID()));
		Assert::AreEqual(2, int(displaySchedule[4].getItemID()));
		Assert::AreEqual(5, int(displaySchedule[5].getItemID()));


		delete day1;
		delete day2;
		delete day3;
		delete day4;
		delete day5;
		delete day6;

		day1 = NULL;
		day2 = NULL;
		day3 = NULL;
		day4 = NULL;
		day5 = NULL;
		day6 = NULL;

	}

	TEST_METHOD(TestSortByCompletion) {
		Schedule mosquitoSchedule;
		vector<Item> displaySchedule;

		Item *day1 = new Item(string("I'm just a larvae"));
		day1->setItemID(1);
		day1->setDescription(string("squirm squirm"));
		day1->setLabel('M');
		day1->setCompletion(false);
		day1->setStartTime(2015, 4, 2);

		Item *day2 = new Item(string("I'm a pupae"));
		day2->setItemID(2);
		day2->setDescription(string("wriggle wriggle"));
		day2->setLabel('M');
		day2->setCompletion(false);
		day2->setStartTime(2015, 4, 3);

		Item *day3 = new Item(string("I'm an adult mosquito now, beeeches"));
		day3->setItemID(3);
		day3->setDescription(string("bzz bzzzz"));
		day3->setLabel('O');
		day3->setCompletion(true);
		day3->setStartTime(2015, 4, 4);

		Item *day4 = new Item(string("Suck some blood"));
		day4->setItemID(4);
		day4->setLabel('P');
		day4->setCompletion(false);
		day4->setStartTime(2015, 4, 6);

		Item *day5 = new Item(string("Suck some more blood"));
		day5->setItemID(5);
		day5->setDescription(string("blood is delish"));
		day5->setLabel('O');
		day5->setCompletion(false);
		day5->setStartTime(2015, 4, 7);

		Item *day6 = new Item(string("Procreate"));
		day6->setItemID(6);
		day6->setDescription(string("Must have babies"));
		day6->setLabel('O');
		day6->setCompletion(true);
		day6->setStartTime(2015, 4, 8);

		mosquitoSchedule.addItem(day1);
		mosquitoSchedule.addItem(day2);
		mosquitoSchedule.addItem(day3);
		mosquitoSchedule.addItem(day4);
		mosquitoSchedule.addItem(day5);
		mosquitoSchedule.addItem(day6);

		mosquitoSchedule.resetDisplaySchedule();
		displaySchedule = mosquitoSchedule.retrieveDisplayScheduleByCompletionStatus();

		Assert::AreEqual(6, int(displaySchedule.size()));

		Assert::AreEqual(1, int(displaySchedule[0].getItemID()));
		Assert::AreEqual(2, int(displaySchedule[1].getItemID()));
		Assert::AreEqual(4, int(displaySchedule[2].getItemID()));
		Assert::AreEqual(5, int(displaySchedule[3].getItemID()));
		Assert::AreEqual(3, int(displaySchedule[4].getItemID()));
		Assert::AreEqual(6, int(displaySchedule[5].getItemID()));

		delete day1;
		delete day2;
		delete day3;
		delete day4;
		delete day5;
		delete day6;

		day1 = NULL;
		day2 = NULL;
		day3 = NULL;
		day4 = NULL;
		day5 = NULL;
		day6 = NULL;

	}

	TEST_METHOD(TestSortByDateCase1) {
		Schedule sem2ExamSchedule;
		vector<Item> expectedSchedule;
		vector<Item> retrievedSchedule;

		Item *item1;
		item1 = new Item;
		item1->setItemName(string("IE2100 Exam"));
		item1->setStartTime(2015, 4, 24, 13, 00);
		item1->setEndTime(2015, 4, 24, 15, 00);
		item1->setLabel('O');

		Item *item2;
		item2 = new Item;
		item2->setItemName(string("IE2130 Exam"));
		item2->setStartTime(2015, 4, 27, 8, 00);
		item2->setEndTime(2015, 4, 27, 10, 00);
		item2->setLabel('O');

		Item *item3;
		item3 = new Item;
		item3->setItemName(string("IE2150 Exam"));
		item3->setStartTime(2015, 4, 21, 13, 00);
		item3->setEndTime(2015, 4, 21, 15, 00);
		item3->setLabel('O');

		sem2ExamSchedule.addItem(item1);
		sem2ExamSchedule.addItem(item2);
		sem2ExamSchedule.addItem(item3);

		expectedSchedule.push_back(*item1);
		expectedSchedule.push_back(*item2);
		expectedSchedule.push_back(*item3);
		sem2ExamSchedule.resetDisplaySchedule();
		retrievedSchedule = sem2ExamSchedule.retrieveDisplaySchedule();
		Assert::AreEqual(expectedSchedule.size(), retrievedSchedule.size());
		Assert::AreEqual(expectedSchedule[0].getItemName(), retrievedSchedule[0].getItemName());
		Assert::AreEqual(expectedSchedule[1].getItemName(), retrievedSchedule[1].getItemName());
		Assert::AreEqual(expectedSchedule[2].getItemName(), retrievedSchedule[2].getItemName());

		expectedSchedule.clear();

		expectedSchedule.push_back(*item3);
		expectedSchedule.push_back(*item1);
		expectedSchedule.push_back(*item2);
		sem2ExamSchedule.resetDisplaySchedule();
		retrievedSchedule = sem2ExamSchedule.retrieveDisplayScheduleByDate();
		Assert::AreEqual(expectedSchedule.size(), retrievedSchedule.size());
		Assert::AreEqual(expectedSchedule[0].getItemName(), retrievedSchedule[0].getItemName());
		Assert::AreEqual(expectedSchedule[1].getItemName(), retrievedSchedule[1].getItemName());
		Assert::AreEqual(expectedSchedule[2].getItemName(), retrievedSchedule[2].getItemName());

		delete item1;
		delete item2;
		delete item3;
		item1 = NULL;
		item2 = NULL;
		item3 = NULL;
	}

	TEST_METHOD(TestSortByDateCase2) {
		Schedule gymSchedule;
		vector<Item> expectedSchedule;
		vector<Item> retrievedSchedule;

		Item *item1;
		item1 = new Item;
		item1->setItemName(string("Back Day"));
		item1->setStartTime(2015, 4, 24);
		item1->setLabel('P');

		Item *item2;
		item2 = new Item;
		item2->setItemName(string("Run and Swim (cardio)"));
		item2->setStartTime(2015, 4, 19, 8, 00);
		item2->setEndTime(2015, 4, 19, 11, 00);
		item2->setLabel('P');

		Item *item3;
		item3 = new Item;
		item3->setItemName(string("Run below 8 minutes for 2.4km"));
		item3->setEndTime(2015, 4, 22, 10, 00);
		item3->setLabel('O');

		gymSchedule.addItem(item1);
		gymSchedule.addItem(item2);
		gymSchedule.addItem(item3);

		expectedSchedule.push_back(*item1);
		expectedSchedule.push_back(*item2);
		expectedSchedule.push_back(*item3);
		gymSchedule.resetDisplaySchedule();
		retrievedSchedule = gymSchedule.retrieveDisplaySchedule();
		Assert::AreEqual(expectedSchedule.size(), retrievedSchedule.size());
		Assert::AreEqual(expectedSchedule[0].getItemName(), retrievedSchedule[0].getItemName());
		Assert::AreEqual(expectedSchedule[1].getItemName(), retrievedSchedule[1].getItemName());
		Assert::AreEqual(expectedSchedule[2].getItemName(), retrievedSchedule[2].getItemName());

		expectedSchedule.clear();

		expectedSchedule.push_back(*item2);
		expectedSchedule.push_back(*item3);
		expectedSchedule.push_back(*item1);
		gymSchedule.resetDisplaySchedule();
		retrievedSchedule = gymSchedule.retrieveDisplayScheduleByDate();
		Assert::AreEqual(expectedSchedule.size(), retrievedSchedule.size());
		Assert::AreEqual(expectedSchedule[0].getItemName(), retrievedSchedule[0].getItemName());
		Assert::AreEqual(expectedSchedule[1].getItemName(), retrievedSchedule[1].getItemName());
		Assert::AreEqual(expectedSchedule[2].getItemName(), retrievedSchedule[2].getItemName());

		delete item1;
		delete item2;
		delete item3;
		item1 = NULL;
		item2 = NULL;
		item3 = NULL;
	}

	TEST_METHOD(TestSortByName) {
		Schedule fishermanSchedule;
		vector<Item> expectedSchedule;
		vector<Item> retrievedSchedule;

		Item *item1;
		item1 = new Item;
		item1->setItemName(string("Ikan Bilis (1000 kgs)"));
		item1->setEndTime(2015, 2, 24);
		item1->setLabel('O');

		Item *item2;
		item2 = new Item;
		item2->setItemName(string("golden Promfret la deyyyy"));
		item2->setEndTime(2015, 6, 19);
		item2->setLabel('O');

		Item *item3;
		item3 = new Item;
		item3->setItemName(string("Ikan Petai"));
		item3->setDescription(string("boss want at least 6kg per piece"));
		item3->setEndTime(2015, 4, 21);
		item3->setLabel('O');

		Item *item4;
		item4 = new Item;
		item4->setItemName(string("Red Snapper/ Red Goby"));
		item4->setEndTime(2015, 5, 29);
		item4->setLabel('O');

		fishermanSchedule.addItem(item1);
		fishermanSchedule.addItem(item2);
		fishermanSchedule.addItem(item3);
		fishermanSchedule.addItem(item4);

		expectedSchedule.push_back(*item1);
		expectedSchedule.push_back(*item2);
		expectedSchedule.push_back(*item3);
		expectedSchedule.push_back(*item4);
		fishermanSchedule.resetDisplaySchedule();
		retrievedSchedule = fishermanSchedule.retrieveDisplaySchedule();
		Assert::AreEqual(expectedSchedule.size(), retrievedSchedule.size());
		Assert::AreEqual(expectedSchedule[0].getItemName(), retrievedSchedule[0].getItemName());
		Assert::AreEqual(expectedSchedule[1].getItemName(), retrievedSchedule[1].getItemName());
		Assert::AreEqual(expectedSchedule[2].getItemName(), retrievedSchedule[2].getItemName());
		Assert::AreEqual(expectedSchedule[3].getItemName(), retrievedSchedule[3].getItemName());

		expectedSchedule.clear();
		expectedSchedule.push_back(*item2);
		expectedSchedule.push_back(*item1);
		expectedSchedule.push_back(*item3);
		expectedSchedule.push_back(*item4);
		fishermanSchedule.resetDisplaySchedule();
		retrievedSchedule = fishermanSchedule.retrieveDisplayScheduleByItemName();
		Assert::AreEqual(expectedSchedule.size(), retrievedSchedule.size());
		Assert::AreEqual(expectedSchedule[0].getItemName(), retrievedSchedule[0].getItemName());
		Assert::AreEqual(expectedSchedule[1].getItemName(), retrievedSchedule[1].getItemName());
		Assert::AreEqual(expectedSchedule[2].getItemName(), retrievedSchedule[2].getItemName());
		Assert::AreEqual(expectedSchedule[3].getItemName(), retrievedSchedule[3].getItemName());

		delete item1;
		delete item2;
		delete item3;
		delete item4;
		item1 = NULL;
		item2 = NULL;
		item3 = NULL;
		item4 = NULL;
	}

	TEST_METHOD(TestSortByLastUpdate) {
		Schedule scheduleSortedByUpdate;
		vector<Item> sortedVector;

		Item *item4 = new Item(string("This is Item #4"));
		item4->setItemID(4);
		item4->setDescription(string("before editing"));

		int time1 = time(0);
		int time2 = time(0);
		while (time2 - time1 < 2) {
			time2 = time(0);
		}

		Item *item2 = new Item(string("This is Item #2"));
		item2->setItemID(2);
		item2->setDescription(string("before editing"));

		time1 = time(0);
		time2 = time(0);
		while (time2 - time1 < 2) {
			time2 = time(0);
		}

		Item *item1 = new Item(string("This is Item #1"));
		item1->setItemID(1);
		item1->setDescription(string("before editing"));

		time1 = time(0);
		time2 = time(0);
		while (time2 - time1 < 2) {
			time2 = time(0);
		}

		Item *item3 = new Item(string("This is Item #3"));
		item3->setItemID(3);
		item3->setDescription(string("before editing"));

		scheduleSortedByUpdate.addItem(item1);
		scheduleSortedByUpdate.addItem(item2);
		scheduleSortedByUpdate.addItem(item3);
		scheduleSortedByUpdate.addItem(item4);

		scheduleSortedByUpdate.resetDisplaySchedule();
		Assert::AreEqual(4, int(scheduleSortedByUpdate.getSizeOfSchedule()));

		sortedVector = scheduleSortedByUpdate.retrieveDisplayScheduleByLastUpdate();
		Assert::AreEqual(item3->getItemID(), sortedVector[0].getItemID());
		Assert::AreEqual(item1->getItemID(), sortedVector[1].getItemID());
		Assert::AreEqual(item2->getItemID(), sortedVector[2].getItemID());
		Assert::AreEqual(item4->getItemID(), sortedVector[3].getItemID());
	}

	};

	TEST_CLASS(TEST_UNDO) {
public:
	TEST_METHOD(ScheduleTestUndoLastCommand) {
		Schedule testSchedule;
		string confirmationFromSchedule;
		Item *item1 = new Item(string("Item number 1 in schedule!"));
		item1->setItemID(1);
		Item *item2 = new Item(string("Item number 2 in schedule!"));
		item2->setItemID(2);
		Item *item3 = new Item(string("Item number 3 in schedule!"));
		item3->setItemID(3);
		Item *item4 = new Item(string("Item number 4 in schedule!"));
		item4->setItemID(4);

		Assert::AreEqual(0, int(testSchedule.getSizeOfSchedule()));
		Assert::AreEqual(0, int(testSchedule.getSizeOfDisplaySchedule()));

		// Testing undoing of Add
		testSchedule.addItem(item1);
		testSchedule.addItem(item2);

		Assert::AreEqual(2, int(testSchedule.getSizeOfSchedule()));
		testSchedule.resetDisplaySchedule();
		Assert::AreEqual(2, int(testSchedule.getSizeOfDisplaySchedule()));

		confirmationFromSchedule = testSchedule.undoLastCommand();
		Assert::AreEqual(string("ADD") + item2->displayItemFullDetails(), confirmationFromSchedule);

		Assert::AreEqual(1, int(testSchedule.getSizeOfSchedule()));
		testSchedule.resetDisplaySchedule();
		Assert::AreEqual(1, int(testSchedule.getSizeOfDisplaySchedule()));

		confirmationFromSchedule = testSchedule.undoLastCommand();
		Assert::AreEqual(string("ADD") + item1->displayItemFullDetails(), confirmationFromSchedule);

		Assert::AreEqual(0, int(testSchedule.getSizeOfSchedule()));
		testSchedule.resetDisplaySchedule();
		Assert::AreEqual(0, int(testSchedule.getSizeOfDisplaySchedule()));

		// Testing undoing when no available commands to undo
		confirmationFromSchedule = testSchedule.undoLastCommand();
		Assert::AreEqual(string("ERROR: Undo has reached its limit."), confirmationFromSchedule);

		// Testing undoing of Delete
		testSchedule.addItem(item3);
		testSchedule.addItem(item1);
		testSchedule.addItem(item2);

		Assert::AreEqual(3, int(testSchedule.getSizeOfSchedule()));
		testSchedule.resetDisplaySchedule();
		Assert::AreEqual(3, int(testSchedule.getSizeOfDisplaySchedule()));

		testSchedule.deleteItemGivenDisplayVectorIndex(2);
		Assert::AreEqual(2, int(testSchedule.getSizeOfSchedule()));
		testSchedule.resetDisplaySchedule();
		Assert::AreEqual(2, int(testSchedule.getSizeOfDisplaySchedule()));
		Assert::AreEqual(item3->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(1).getItemName());
		Assert::AreEqual(item2->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(2).getItemName());

		confirmationFromSchedule = testSchedule.undoLastCommand();
		Assert::AreEqual(string("DELETE") + item1->displayItemFullDetails(), confirmationFromSchedule);
		Assert::AreEqual(3, int(testSchedule.getSizeOfSchedule()));
		testSchedule.resetDisplaySchedule();
		Assert::AreEqual(3, int(testSchedule.getSizeOfDisplaySchedule()));
		Assert::AreEqual(item3->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(1).getItemName());
		Assert::AreEqual(item2->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(2).getItemName());
		Assert::AreEqual(item1->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(3).getItemName());

		confirmationFromSchedule = testSchedule.undoLastCommand();
		Assert::AreEqual(string("ADD") + item2->displayItemFullDetails(), confirmationFromSchedule);
		Assert::AreEqual(2, int(testSchedule.getSizeOfSchedule()));
		testSchedule.resetDisplaySchedule();
		Assert::AreEqual(2, int(testSchedule.getSizeOfDisplaySchedule()));
		Assert::AreEqual(item3->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(1).getItemName());
		Assert::AreEqual(item1->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(2).getItemName());

		// Testing undoing of Edit
		Item *itemToReplace = new Item(string("This is the Item to replace the edited Item"));
		itemToReplace->setItemID(3);

		testSchedule.addItem(item2);
		testSchedule.addItem(item4);

		Assert::AreEqual(4, int(testSchedule.getSizeOfSchedule()));
		testSchedule.resetDisplaySchedule();
		Assert::AreEqual(4, int(testSchedule.getSizeOfDisplaySchedule()));

		Assert::AreEqual(item3->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(1).getItemName());
		testSchedule.replaceItemGivenDisplayVectorIndex(itemToReplace, 1);
		testSchedule.resetDisplaySchedule();	// <<< This step is very important
		Assert::AreEqual(4, int(testSchedule.getSizeOfSchedule()));
		Assert::AreEqual(4, int(testSchedule.getSizeOfDisplaySchedule()));
		Assert::AreEqual(itemToReplace->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(1).getItemName());
		Assert::AreEqual(item1->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(2).getItemName());
		Assert::AreEqual(item2->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(3).getItemName());
		Assert::AreEqual(item4->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(4).getItemName());
		Assert::AreEqual(itemToReplace->getItemID(), testSchedule.retrieveItemGivenDisplayVectorIndex(1).getItemID());
		Assert::AreEqual(item1->getItemID(), testSchedule.retrieveItemGivenDisplayVectorIndex(2).getItemID());
		Assert::AreEqual(item2->getItemID(), testSchedule.retrieveItemGivenDisplayVectorIndex(3).getItemID());
		Assert::AreEqual(item4->getItemID(), testSchedule.retrieveItemGivenDisplayVectorIndex(4).getItemID());

		confirmationFromSchedule = testSchedule.undoLastCommand();
		Assert::AreEqual(string("REPLACE") + item3->displayItemFullDetails(), confirmationFromSchedule);
		testSchedule.resetDisplaySchedule();	// <<< This step is very important
		Assert::AreEqual(item3->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(1).getItemName());
		Assert::AreEqual(item1->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(2).getItemName());
		Assert::AreEqual(item2->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(3).getItemName());
		Assert::AreEqual(item4->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(4).getItemName());

		testSchedule.clearDisplaySchedule();
		testSchedule.resetDisplaySchedule();
		Assert::AreEqual(0, int(testSchedule.getSizeOfDisplaySchedule()));
		Assert::AreEqual(0, int(testSchedule.getSizeOfSchedule()));

		confirmationFromSchedule = testSchedule.undoLastCommand();
		testSchedule.resetDisplaySchedule();
		Assert::AreEqual(string("4"), confirmationFromSchedule);
		Assert::AreEqual(4, int(testSchedule.getSizeOfDisplaySchedule()));
		Assert::AreEqual(4, int(testSchedule.getSizeOfSchedule()));

		delete item1;
		delete item2;
		delete item3;
		delete item4;
		delete itemToReplace;
		item1 = NULL;
		item2 = NULL;
		item3 = NULL;
		item4 = NULL;
		itemToReplace = NULL;
	}

//	Testing of private function muted.
/*	TEST_METHOD(ScheduleTestUndoAdd) {
	Schedule testSchedule;
	Item *item1 = new Item(string("Item number 1 in schedule!"));
	item1->setItemID(1);
	Item *item2 = new Item(string("Item number 2 in schedule!"));
	item2->setItemID(2);

	Assert::AreEqual(0, int(testSchedule.getSizeOfSchedule()));
	Assert::AreEqual(0, int(testSchedule.getSizeOfDisplaySchedule()));

	testSchedule.addItem(item1);
	testSchedule.addItem(item2);

	Assert::AreEqual(2, int(testSchedule.getSizeOfSchedule()));
	testSchedule.resetDisplaySchedule();
	Assert::AreEqual(2, int(testSchedule.getSizeOfDisplaySchedule()));

	testSchedule.undoAdd(*item2);

	Assert::AreEqual(1, int(testSchedule.getSizeOfSchedule()));
	testSchedule.resetDisplaySchedule();
	Assert::AreEqual(1, int(testSchedule.getSizeOfDisplaySchedule()));
	Assert::AreEqual(item1->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(1).getItemName());

	delete item1;
	delete item2;
	item1 = NULL;
	item2 = NULL;
	}

	TEST_METHOD(ScheduleTestUndoReplace) {
	Schedule testSchedule;
	Item *item1 = new Item(string("Item number 1 in schedule!"));
	item1->setItemID(1);
	Item *item2 = new Item(string("Item number 2 in schedule!"));
	item2->setItemID(2);
	Item *itemToReplaceWith = new Item(string("This is the replaced Item"));
	itemToReplaceWith->setItemID(2);
	Item replacedItemRetrievedFromSchedule;

	Assert::AreEqual(0, int(testSchedule.getSizeOfSchedule()));

	testSchedule.addItem(item1);
	testSchedule.addItem(item2);

	Assert::AreEqual(2, int(testSchedule.getSizeOfSchedule()));
	Assert::AreEqual(0, int(testSchedule.getSizeOfDisplaySchedule()));

	testSchedule.resetDisplaySchedule();
	Assert::AreEqual(2, int(testSchedule.getSizeOfDisplaySchedule()));

	testSchedule.replaceItemGivenDisplayVectorIndex(itemToReplaceWith, 2);
	testSchedule.resetDisplaySchedule();
	replacedItemRetrievedFromSchedule = testSchedule.retrieveItemGivenDisplayVectorIndex(2);
	Assert::AreEqual(itemToReplaceWith->getItemName(), replacedItemRetrievedFromSchedule.getItemName());

	testSchedule.undoReplace(*item2);
	testSchedule.resetDisplaySchedule();
	replacedItemRetrievedFromSchedule = testSchedule.retrieveItemGivenDisplayVectorIndex(2);
	Assert::AreEqual(item2->getItemName(), replacedItemRetrievedFromSchedule.getItemName());

	delete item1;
	delete item2;
	delete itemToReplaceWith;
	item1 = NULL;
	item2 = NULL;
	itemToReplaceWith = NULL;
	}

	TEST_METHOD(ScheduleTestUndoDelete) {
	Schedule testSchedule;
	Item *item1 = new Item(string("Item number 1 in schedule!"));
	item1->setItemID(1);
	Item *item2 = new Item(string("Item number 2 in schedule!"));
	item2->setItemID(2);

	Assert::AreEqual(0, int(testSchedule.getSizeOfSchedule()));

	testSchedule.addItem(item1);
	testSchedule.addItem(item2);

	Assert::AreEqual(2, int(testSchedule.getSizeOfSchedule()));
	Assert::AreEqual(0, int(testSchedule.getSizeOfDisplaySchedule()));

	testSchedule.resetDisplaySchedule();
	Assert::AreEqual(2, int(testSchedule.getSizeOfDisplaySchedule()));

	testSchedule.deleteItemGivenDisplayVectorIndex(2);

	Assert::AreEqual(1, int(testSchedule.getSizeOfSchedule()));
	testSchedule.resetDisplaySchedule();
	Assert::AreEqual(1, int(testSchedule.getSizeOfDisplaySchedule()));
	Assert::AreEqual(item1->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(1).getItemName());

	testSchedule.undoDelete(*item2);

	Assert::AreEqual(2, int(testSchedule.getSizeOfSchedule()));
	testSchedule.resetDisplaySchedule();
	Assert::AreEqual(2, int(testSchedule.getSizeOfDisplaySchedule()));
	Assert::AreEqual(item2->getItemName(), testSchedule.retrieveItemGivenDisplayVectorIndex(2).getItemName());

	delete item1;
	delete item2;
	item1 = NULL;
	item2 = NULL;
	}

	*/

	};
}

namespace HistoryTest {
	TEST_CLASS(TEST_HISTORY) {
public:
//	Testing of private function muted.
/*	TEST_METHOD(HistoryTestIsNormalHistoryCommand) {
	History testHistory;
	bool isValidHistoryCmd;

	isValidHistoryCmd = testHistory.isNormalHistoryCommand(string("ADD"));
	Assert::AreEqual(true, isValidHistoryCmd);

	isValidHistoryCmd = testHistory.isNormalHistoryCommand(string("DELETE"));
	Assert::AreEqual(true, isValidHistoryCmd);

	isValidHistoryCmd = testHistory.isNormalHistoryCommand(string("REPLACE"));
	Assert::AreEqual(true, isValidHistoryCmd);

	isValidHistoryCmd = testHistory.isNormalHistoryCommand(string("Add"));
	Assert::AreEqual(false, isValidHistoryCmd);

	isValidHistoryCmd = testHistory.isNormalHistoryCommand(string("Delete"));
	Assert::AreEqual(false, isValidHistoryCmd);

	isValidHistoryCmd = testHistory.isNormalHistoryCommand(string("Replace"));
	Assert::AreEqual(false, isValidHistoryCmd);

	isValidHistoryCmd = testHistory.isNormalHistoryCommand(string("whattt"));
	Assert::AreEqual(false, isValidHistoryCmd);

	isValidHistoryCmd = testHistory.isNormalHistoryCommand(string("ADDD"));
	Assert::AreEqual(false, isValidHistoryCmd);
	}

	TEST_METHOD(HistoryTestIsClearCommand) {
	History testHistory;
	bool isClearCmd;

	isClearCmd = testHistory.isClearCommand(string("CLEAR"));
	Assert::AreEqual(true, isClearCmd);

	isClearCmd = testHistory.isClearCommand(string("Clear"));
	Assert::AreEqual(false, isClearCmd);

	isClearCmd = testHistory.isClearCommand(string("ADD"));
	Assert::AreEqual(false, isClearCmd);
	}

	TEST_METHOD(HistoryTestIsValidUndoCall) {
	History testHistory;
	bool isValidCallForUndo;

	isValidCallForUndo = testHistory.isValidUndoCall();
	Assert::AreEqual(false, isValidCallForUndo);

	string command1 = "ADD";
	Item item1(string("This is the first item"));
	testHistory.addCommand(command1, item1);

	isValidCallForUndo = testHistory.isValidUndoCall();
	Assert::AreEqual(true, isValidCallForUndo);
	}

	*/

	TEST_METHOD(HistoryTestAddCommand) {
		History testHistory;
		string returnMessage;

		string command1 = "ADD";
		Item item1(string("This is the first item"));

		string command2 = "DELETE";
		Item item2(string("This is the second item"));

		string command3 = "REPLACE";
		Item item3(string("This is the third item"));

		string command4 = "ADDD";
		Item item4(string("This is the fourth item"));

		string command5 = "SIT";
		Item item5(string("This is the fifth item"));

		returnMessage = testHistory.addCommand(command1, item1);
		Assert::AreEqual(command1 + item1.displayItemFullDetails(), returnMessage);

		returnMessage = testHistory.addCommand(command2, item2);
		Assert::AreEqual(command2 + item2.displayItemFullDetails(), returnMessage);

		returnMessage = testHistory.addCommand(command3, item3);
		Assert::AreEqual(command3 + item3.displayItemFullDetails(), returnMessage);

		returnMessage = testHistory.addCommand(command4, item4);
		Assert::AreEqual(string("ERROR: Command and Item were not recorded."), returnMessage);

		returnMessage = testHistory.addCommand(command5, item5);
		Assert::AreEqual(string("ERROR: Command and Item were not recorded."), returnMessage);
	}

	TEST_METHOD(HistoryTestAddClearCommand) {
		History testHistory;
		string returnMessage;
		vector<Item> clearedSchedule;
		Item* item1 = new Item(string("helloworld"));

		clearedSchedule.push_back(*item1);
		returnMessage = testHistory.addClearCommand(clearedSchedule);
		Assert::AreEqual(string("CLEAR"), returnMessage);
	}

	TEST_METHOD(HistoryTestUndoLastCommand) {
		History testHistory;
		string returnMessage;
		string commandFromHistory;
		Item latestItemFromHistory;
		vector <Item> clearedSchedule;
		vector <Item> latestClearedScheduleFromHistory;

		returnMessage = testHistory.undoLastCommand(commandFromHistory, latestItemFromHistory, latestClearedScheduleFromHistory);
		Assert::AreEqual(string("ERROR: Undo has reached its limit."), returnMessage);

		string command1 = "ADD";
		Item item1(string("What's up with it, vanilla face?"));
		testHistory.addCommand(command1, item1);
		returnMessage = testHistory.undoLastCommand(commandFromHistory, latestItemFromHistory, latestClearedScheduleFromHistory);
		Assert::AreEqual(command1 + "\n" + item1.displayItemFullDetails(), returnMessage);

		testHistory.addCommand(command1, item1);
		clearedSchedule.push_back(item1);
		testHistory.addClearCommand(clearedSchedule);
		returnMessage = testHistory.undoLastCommand(commandFromHistory, latestItemFromHistory, latestClearedScheduleFromHistory);
		Assert::AreEqual(clearedSchedule[0].getItemName(), latestClearedScheduleFromHistory[0].getItemName());
	}
	
	// End of segment: C:\Users\SKR\Documents\main\iStorageTest\StorageTest.cpp





