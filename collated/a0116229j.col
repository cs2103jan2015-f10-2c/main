//@author: a0116229j



	/**
	 * origin: C:\Users\SKR\Documents\main\iLogic\Logic.cpp
	 */

//Coder : Yu Young Bin

#include "Logic.h"
#include <exception>


const string Logic::COMMAND_ADD = "add";
const string Logic::COMMAND_DELETE = "delete";
const string Logic::COMMAND_EDIT = "edit";
const string Logic::COMMAND_UNDO = "undo";
const string Logic::COMMAND_SORT = "sort";
const string Logic::COMMAND_SEARCH = "search";
const string Logic::COMMAND_VIEW = "view";
const string Logic::COMMAND_DONE = "done";
const string Logic::COMMAND_UNDONE = "undone";
const string Logic::COMMAND_SAVE = "save";
const string Logic::COMMAND_CLEAR = "clear";
const string Logic::COMMAND_EXIT = "exit";
const string Logic::MODIFIER_NAME = "name";
const string Logic::MODIFIER_START = "start";
const string Logic::MODIFIER_END = "end";
const string Logic::MODIFIER_DESCRIPTION = "description";
const string Logic::MODIFIER_LABEL = "label";
const string Logic::MODIFIER_PRIORITY = "priority";
const string Logic::MODIFIER_COMPLETION = "done";
const string Logic::SORT_NAME = "name";
const string Logic::SORT_DATE = "date";
const string Logic::SORT_PRIORITY = "priority";
const string Logic::SORT_COMPLETION = "done";
const string Logic::SORT_LAST_UPDATE = "update";
const string Logic::FILTER_COMPLETION = "done";
const string Logic::FILTER_COMPLETION_UNDONE = "undone";
const string Logic::FILTER_PRIORITY_HIGH = "high";
const string Logic::FILTER_PRIORITY_MEDIUM = "medium";
const string Logic::FILTER_PRIORITY_LOW = "low";
const string Logic::FILTER_LABEL = "label";
const string Logic::FILTER_ALL = "all";
const string Logic::FILTER_KEYWORD = "keyword";
const string Logic::FILTER_DATE = "date";

const string Logic::ACCEPTABLE_PRIORITY_HIGH_1 = "high";
const string Logic::ACCEPTABLE_PRIORITY_HIGH_2 = "h";
const string Logic::ACCEPTABLE_PRIORITY_HIGH_3 = "H";
const string Logic::ACCEPTABLE_PRIORITY_MEDIUM_1 = "medium";
const string Logic::ACCEPTABLE_PRIORITY_MEDIUM_2 = "M";
const string Logic::ACCEPTABLE_PRIORITY_MEDIUM_3 = "m";
const string Logic::ACCEPTABLE_PRIORITY_LOW_1 = "low";
const string Logic::ACCEPTABLE_PRIORITY_LOW_2 = "L";
const string Logic::ACCEPTABLE_PRIORITY_LOW_3 = "l";

const char Logic:: PRIORITY_HIGH = 'H';
const char Logic::PRIORITY_MEDIUM = 'M';
const char Logic::PRIORITY_LOW = 'L';
const char Logic::PRIORITY_INVALID = 'E';

const string Logic::TEXTFILE_TO_STORE_DIRECTORY_AND_FILENAME = "basicinformation.txt";
const string Logic::DEFAULT_FILENAME = "save.txt";
const string Logic::DEFAULT_SORTING = "date";

const string Logic::MESSAGE_TASK = "Task ";
const string Logic::MESSAGE_SUCCESSFUL_ADD = "Task added to schedule : ";
const string Logic::MESSAGE_SUCCESSFUL_DELETE = "Task is deleted from schedule";
const string Logic::MESSAGE_SUCCESSFUL_EDIT = " is edited : ";
const string Logic::MESSAGE_SUCCESSFUL_SORT = "Schedule sorted by : ";
const string Logic::MESSAGE_SUCCESSFUL_VIEW = "Schedule filtered by : ";
const string Logic::MESSAGE_SUCCESSFUL_SAVE = "Save directory changed to : ";
const string Logic::MESSAGE_SUCCESSFUL_UNDO = "Last action reversed";
const string Logic::MESSAGE_SUCCESSFUL_MARK_DONE = " is completed";
const string Logic::MESSAGE_SUCCESSFUL_MARK_UNDONE = " is undone";
const string Logic::MESSAGE_SUCCESSFUL_CHANGE_COMPLETION = "completion changed to : ";
const string Logic::MESSAGE_CLEAR = "Schedule cleared";
const string Logic::MESSAGE_RETRIEVED_FROM_TEXT_FILE = "Retrieved from save file";
const string Logic::MESSAGE_FILE_NOT_EXISTING = "File not existing";
const string Logic::MESSAGE_FAILED_ADD = "Unable to add task : ";
const string Logic::MESSAGE_FAILED_DELETE = "Unable to delete task : ";
const string Logic::MESSAGE_FAILED_EDIT = "Unable to edit task : ";
const string Logic::MESSAGE_FAILED_VIEW = "Unable to filter schedule : invalid filter type";
const string Logic::MESSAGE_FAILED_UNDO = "Unable to undo last action";
const string Logic::MESSAGE_FAILED_SORT = "Unable to change sorting : ";
const string Logic::MESSAGE_INVALID_PRIORITY = "Invalid Priority Type";
const string Logic::MESSAGE_SUCCESS = "Execution success";
const string Logic::MESSAGE_INVALID_SORTTYPE = "Invalid sort type";
const string Logic::MESSAGE_INVALID_INPUT = "Invalid command";
const string Logic::MESSAGE_INVALID_INDEX = "Invalid index";
const string Logic::MESSAGE_INVALID_FILTERTYPE = "Invalid filter type";
const string Logic::MESSAGE_INVALID_MODIFIER = "Invalid modifier";
const string Logic::MESSAGE_INVALID_COMPLETION = "invalid completion";
const string Logic::MESSAGE_TASK_FOUND = "Tasks containing : ";
const string Logic::MESSAGE_NO_TASK_FOUND = "No task can be found";
const string Logic::MESSAGE_UNABLE_TO_UNDO = "ERROR: Undo has reached its limit.";
const string Logic::MESSAGE_LOGIC = "LOGIC::";
const string Logic::MESSAGE_DEFAULT = "default";
const string Logic::MESSAGE_READFILE_COMPLETE = "readfile completed";
const string Logic::MESSAGE_WRITEFILE_COMPLETE = "writefile completed";
const string Logic::EMPTY_STRING = "";
const string Logic::END_OF_FOLDER_NAME = "/";
const string Logic::PLUS = "+";
const string Logic::SPACE_BAR = " ";
const char Logic::CHAR_SPACE_BAR = ' ';
const char Logic::CHAR_TAB = '\t';

const unsigned int Logic::FIRST_INDEX = 0;
const unsigned int Logic::SIZE_ZERO = 0;
const unsigned int Logic::SIZE_INVALID = 1;
const unsigned int Logic::NOT_FOUND = -1;
const unsigned int Logic::EMPTY_TIME_FIELD = -1;
const unsigned int Logic::TIME_FIELD_REMOVED = -2;
const unsigned int Logic::INITIAL_ITEM_ID = 1;
const unsigned int Logic::FIRST_HOUR = 0;
const unsigned int Logic::FIRST_MINUTE = 0;
const unsigned int Logic::FINAL_HOUR = 23;
const unsigned int Logic::FINAL_MINUTE = 59;


char Logic::buffer[300];
const string Logic::SCHEDULE_HEAD = "-------------------------------------------------------------------------------\nSCHEDULE\n-------------------------------------------------------------------------------";
const string Logic::SCHEDULE_END = "-------------------------------------------------------------------------------";
const string Logic::ADD_TASK_SUCCESSFUL = "Task is added to schedule";
const string Logic::DELETE_TASK_SUCCESSFUL = "Task %d is removed from schedule";
const string Logic::EDIT_TASK_SUCCESSFUL = "Task %d is edited from schedule";
const string Logic::SORT_TASK_SUCCESSFUL = "Sorting Changed to : ";
const string Logic::MARK_DONE_SUCCESSFUL = "Task %d is done";
const string Logic::SCHEDULE_RETRIEVED = "Schedule Retrieved";
const string Logic::ADD_TASK_FAILED = "Task cannot be added to schedule";
const string Logic::DELETE_TASK_FAILED = "Task cannot be removed from schedule";
const string Logic::INVALID_LINE_INDEX = "invalid line index";
const string Logic::SORT_TASK_FAILED = "Invalid Sort Method";
const string Logic::EDIT_TASK_FAILED = "Task cannot be edited from schedule";


Logic::Logic() {
	_nextItemID = INITIAL_ITEM_ID;
	//Initialised to 1, failure in add,delete,add function will return an item with ID = 0
	_scheduleSize = SIZE_ZERO;
	//schedule size initialised to 0
	_directoryToBeSaved = EMPTY_STRING;
	//if saving directory is an empty string, the directory is set to default
	_fileNameToBeSaved = DEFAULT_FILENAME;
	//default file name is save.txt
	_currentSorting = DEFAULT_SORTING;
	//default sorting is by date
	_currentFilter = FILTER_ALL;
	//default filter is view all

}


Logic::~Logic() {}


/////////////////////////
////*PRINT FUNCTIONS*////
/////////////////////////

/*All the print functions are for Command line prompt debugging purposes*/

void Logic::printSchedule(vector<Item> retrievedDisplaySchedule){
	cout << endl;
	cout << SCHEDULE_HEAD << endl;
	
	for (unsigned int lineNumber = FIRST_INDEX; lineNumber < retrievedDisplaySchedule.size(); lineNumber++){
		cout << "[Item " << lineNumber + 1 << "]" << endl;
		printItem(retrievedDisplaySchedule[lineNumber]);
		if (lineNumber != retrievedDisplaySchedule.size() - 1) {
			cout << endl;
		}
	}
	cout << SCHEDULE_END << endl;
	cout << endl;
}


void Logic::printItem(Item itemToBePrinted){
	cout << itemToBePrinted.displayItemForUser();
	return;
}


void Logic::printAddTaskSuccessful(string itemInformationToBePrinted){
	sprintf_s(buffer, ADD_TASK_SUCCESSFUL.c_str(), itemInformationToBePrinted);
	cout << buffer << endl;
}


void Logic::printDeleteTaskSuccessful(int lineNumberToBeDeleted){
	sprintf_s(buffer, DELETE_TASK_SUCCESSFUL.c_str(), lineNumberToBeDeleted);
	cout << buffer << endl;
}


void Logic::printEditTaskSuccessful(int lineNumberToBeEdited){
	sprintf_s(buffer, EDIT_TASK_SUCCESSFUL.c_str(), lineNumberToBeEdited);
	cout << buffer << endl;
}


void Logic::printSortTaskSuccessful(){
	cout << SORT_TASK_SUCCESSFUL << _currentSorting << endl;
}


void Logic::printMarkDoneSuccessful(unsigned int lineIndex){
	sprintf_s(buffer, MARK_DONE_SUCCESSFUL.c_str(), lineIndex);
	cout << buffer << endl;
}


void Logic::printAddTaskFailed(ItemVerification verifier){
	cout << ADD_TASK_FAILED << endl;
	return;
}

void Logic::printDeleteTaskFailed(){
	cout << DELETE_TASK_FAILED << endl;
	cout << INVALID_LINE_INDEX << endl;
	return;
}

void Logic::printEditTaskInvalidLineIndex(){
	cout << EDIT_TASK_FAILED << endl;
	cout << INVALID_LINE_INDEX << endl;
	return;
}


void Logic::printUndo(){
	cout << MESSAGE_SUCCESSFUL_UNDO << endl;
}


void Logic::printSortTaskFailed(){
	cout << SORT_TASK_FAILED << endl;
	return;
}
void Logic::printEditTaskInvalidItemParts(ItemVerification verifier){
	cout << EDIT_TASK_FAILED << endl;
	return;
}

void Logic::printInvalidInput(){
	cout << MESSAGE_INVALID_INPUT << endl << endl;
}

void Logic::printInvalidLineIndex(){
	cout << INVALID_LINE_INDEX << endl;
}


void Logic::printInvalidViewOption(){
	cout << MESSAGE_INVALID_FILTERTYPE << endl;
}


void Logic::printViewChanged(){
	cout << MESSAGE_SUCCESSFUL_VIEW << _currentFilter << endl;
}

void Logic::printChangeSavingDirectorySuccessful(){
	cout << MESSAGE_SUCCESSFUL_SAVE << _directoryToBeSaved << endl;
}



////////////////////////
////*MAIN FUNCTIONS*////
////////////////////////


MESSAGE_AND_SCHEDULE Logic::initiateCommandAction(string input) {
	list<COMMAND_AND_TEXT> parseInfoToBeProcessed = getParseInfo(_logicParser, input);
	assert(parseInfoToBeProcessed.size() > SIZE_ZERO);

	string command = parseInfoToBeProcessed.begin()->command;
	string itemInformation = parseInfoToBeProcessed.begin()->text;
	string returnMessage;
	MESSAGE_AND_SCHEDULE userDisplayInformation;
	list<COMMAND_AND_TEXT>::iterator iter;

	try{
		if (command == COMMAND_ADD) {
			returnMessage = addTask(parseInfoToBeProcessed);
		} else if (command == COMMAND_DELETE) {
			unsigned int lineIndexToBeDeleted = convertToDigit(itemInformation);
			returnMessage = deleteTask(lineIndexToBeDeleted);
		} else if (command == COMMAND_EDIT){
			unsigned int lineIndexToBeEdited = convertToDigit(itemInformation);
			returnMessage = editTask(parseInfoToBeProcessed, lineIndexToBeEdited);
		} else if (command == COMMAND_UNDO){
			returnMessage = undoPreviousAction();
		} else if (command == COMMAND_SORT){
			returnMessage = changeCurrentSorting(itemInformation);
		} else if (command == COMMAND_SEARCH){
			returnMessage = modifyKeywordVec(itemInformation);
		} else if (command == COMMAND_VIEW){
			clearKeyWordVec();
			returnMessage = filterTask(itemInformation);
		} else if (command == COMMAND_SAVE){
			changeSavingDirectory(itemInformation);
			returnMessage = MESSAGE_SUCCESSFUL_SAVE + getDirectoryAndFileName();
		} else if (command == COMMAND_CLEAR){
			_logicSchedule.clearDisplaySchedule();
			returnMessage = MESSAGE_CLEAR;
		} else if (command == COMMAND_EXIT){
			saveBasicInformationToTextFile();
			exit(0);
		} else if (command == COMMAND_DONE){
			unsigned int lineIndex = convertToDigit(itemInformation);
			returnMessage = markDone(lineIndex);
		} else if (command == COMMAND_UNDONE){
			unsigned int lineIndex = convertToDigit(itemInformation);
			returnMessage = markUndone(lineIndex);
		} else {
			printInvalidInput();
			returnMessage = MESSAGE_INVALID_INPUT;
			throw MESSAGE_LOGIC + MESSAGE_INVALID_INPUT;
		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}

	userDisplayInformation = returnUserDisplayInformation(returnMessage);
	return userDisplayInformation;
}


MESSAGE_AND_SCHEDULE Logic::returnUserDisplayInformation(string returnMessage){
	resetAndGetDisplaySchedule();

	vector<Item> displayVector = sortTask();
	MESSAGE_AND_SCHEDULE userDisplayInformation;
	userDisplayInformation.message = returnMessage;
	userDisplayInformation.displaySchedule = displayVector;
	writeDataOntoFile();
	return userDisplayInformation;
}


list<COMMAND_AND_TEXT> Logic::getParseInfo(iParser parser, string input){
	parser.parse(input);
	return parser.getParseInfo();
}


////////////////////////////////////
////*ADD TASK RELATED FUNCTIONS*////
////////////////////////////////////


string Logic::addTask(list<COMMAND_AND_TEXT> parseInfoToBeProcessed){
	assert(parseInfoToBeProcessed.size() > SIZE_ZERO);
	Item *newItemToBeAdded;
	newItemToBeAdded = new Item;

	setItemNameAndIDForNewItem(newItemToBeAdded, parseInfoToBeProcessed);
	modifyItem(parseInfoToBeProcessed, newItemToBeAdded);

	ItemVerification verifier(*newItemToBeAdded, _nextItemID);
	try{
		if (verifier.isValidItem()) {
			string returnMessage = addItemToSchedule(newItemToBeAdded);
			return returnMessage;
		} else{
			throw MESSAGE_LOGIC + MESSAGE_FAILED_ADD;
		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		
	}

	string errorList = getErrorList(verifier);

	_logicLogger.writeToLogFile(MESSAGE_LOGIC + MESSAGE_FAILED_ADD + errorList);

	removeItemPointer(newItemToBeAdded);

	return MESSAGE_FAILED_ADD + errorList;
}


string Logic::addItemToSchedule(Item* newItemToBeAdded){
	string addCompleted = _logicSchedule.addItem(newItemToBeAdded);
	string returnMessage = MESSAGE_SUCCESSFUL_ADD + newItemToBeAdded->getItemName();
	increaseItemID();
	printAddTaskSuccessful(addCompleted);
	removeItemPointer(newItemToBeAdded);
	return returnMessage;
}


void Logic::setItemNameAndIDForNewItem(Item *newItem, list<COMMAND_AND_TEXT> parseInfoToBeProcessed){
	assert(parseInfoToBeProcessed.size() > SIZE_ZERO);
	newItem->setItemName(parseInfoToBeProcessed.begin()->text);
	newItem->setItemID(_nextItemID);
}


unsigned int Logic::increaseItemID(){
	assert(_nextItemID >= SIZE_ZERO);
	_nextItemID++;
	return _nextItemID;
}


void Logic::removeItemPointer(Item* itemPointer){
	assert(itemPointer != NULL);
	itemPointer = NULL;
	delete itemPointer;
}





///////////////////////////////////////
////*DELETE TASK RELATED FUNCTIONS*////
///////////////////////////////////////


string Logic::deleteTask(unsigned int lineIndexToBeDeleted){
	try{
		if (isValidLineIndex(lineIndexToBeDeleted)){
			string displayMessage = deleteItemFromSchedule(lineIndexToBeDeleted);
			return displayMessage;
		} else{
			printDeleteTaskFailed();
			throw MESSAGE_LOGIC + INVALID_LINE_INDEX;
		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}
	return  MESSAGE_FAILED_DELETE + MESSAGE_INVALID_INDEX;
}


string Logic::deleteItemFromSchedule(unsigned int lineIndexToBeDeleted){
	assert(lineIndexToBeDeleted > SIZE_ZERO);
	_logicSchedule.deleteItemGivenDisplayVectorIndex(lineIndexToBeDeleted);
	printDeleteTaskSuccessful(lineIndexToBeDeleted);
	return MESSAGE_SUCCESSFUL_DELETE;
}


int Logic::convertToDigit(string text) {
	int digit;
	istringstream convert(text);
	convert >> digit;
	return digit;
}

string Logic::undoPreviousAction(){
	string message = _logicSchedule.undoLastCommand();
	try{
		if (message != MESSAGE_UNABLE_TO_UNDO){
			return MESSAGE_SUCCESSFUL_UNDO;
		} else{
			throw MESSAGE_LOGIC + MESSAGE_UNABLE_TO_UNDO;
		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}
	return MESSAGE_FAILED_UNDO;
}


/////////////////////////////////////
////*EDIT TASK RELATED FUNCTIONS*////
/////////////////////////////////////


string Logic::editTask(list<COMMAND_AND_TEXT> parseInfoToBeProcessed, unsigned int lineIndexToBeEdited){
	assert(parseInfoToBeProcessed.size() > SIZE_ZERO);
	try{
		if (parseInfoToBeProcessed.size() == SIZE_INVALID){
			return MESSAGE_FAILED_EDIT + MESSAGE_INVALID_INPUT;
		} else if (isValidLineIndex(lineIndexToBeEdited)){

			Item *editedItemToBeReplaced;
			editedItemToBeReplaced = new Item;
			*editedItemToBeReplaced = _logicSchedule.retrieveItemGivenDisplayVectorIndex(lineIndexToBeEdited);
			string modifiedParts = modifyItem(parseInfoToBeProcessed, editedItemToBeReplaced);

			ItemVerification verifier(*editedItemToBeReplaced, editedItemToBeReplaced->getItemID());
			if (verifier.isValidItem()){
				replaceItemInSchedule(editedItemToBeReplaced, lineIndexToBeEdited);
				return MESSAGE_TASK + to_string(lineIndexToBeEdited) + MESSAGE_SUCCESSFUL_EDIT + modifiedParts;
			} else{
				string errorList = getErrorList(verifier);
				removeItemPointer(editedItemToBeReplaced);
				printEditTaskInvalidItemParts(verifier);
				return MESSAGE_FAILED_EDIT + errorList;
			}

		} else{
			printEditTaskInvalidLineIndex();
			throw MESSAGE_LOGIC + MESSAGE_FAILED_EDIT + MESSAGE_INVALID_INDEX;
		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}
	return MESSAGE_FAILED_EDIT + MESSAGE_INVALID_INDEX;
}


string Logic::replaceItemInSchedule(Item* editedItemToBeReplaced, unsigned int lineIndexToBeEdited){
	assert(lineIndexToBeEdited > SIZE_ZERO);
	_logicSchedule.replaceItemGivenDisplayVectorIndex(editedItemToBeReplaced, lineIndexToBeEdited);
	removeItemPointer(editedItemToBeReplaced);
	return MESSAGE_SUCCESSFUL_EDIT;
}


string Logic::modifyItem(list<COMMAND_AND_TEXT> parseInfoToBeProcessed, Item* itemToBeModified){
	assert(parseInfoToBeProcessed.size() > SIZE_ZERO);
	list<COMMAND_AND_TEXT>::iterator iter;
	string modifiedItemParts = EMPTY_STRING;
	for (iter = ++parseInfoToBeProcessed.begin(); iter != parseInfoToBeProcessed.end(); ++iter){
		modifyItemParts(iter, itemToBeModified, modifiedItemParts);
	}
	return modifiedItemParts;
}


string Logic::modifyItemParts(list<COMMAND_AND_TEXT>::iterator iter, Item* itemToBeModified, string& modifiedItemPartsForDisplay){
	string modifier = iter->command;
	assert(modifier != EMPTY_STRING);
	modifiedItemPartsForDisplay = modifiedItemPartsForDisplay + modifier + SPACE_BAR;
	try{
		if (modifier == MODIFIER_NAME){
			itemToBeModified->setItemName(iter->text);
		} else if (modifier == MODIFIER_DESCRIPTION){
			string descriptionToBeAdded = iter->text;
			itemToBeModified->setDescription(descriptionToBeAdded);
		} else if (modifier == MODIFIER_START){
			DateTime startTimeToBeModified = itemToBeModified->getStartTime();
			itemToBeModified->setStartTime(interpreteDateTime(iter->text, itemToBeModified->getStartTime()));
		} else if (modifier == MODIFIER_END){
			itemToBeModified->setEndTime(interpreteDateTime(iter->text, itemToBeModified->getEndTime()));
		} else if (modifier == MODIFIER_LABEL){
			char labelToBeModified = iter->text[FIRST_INDEX];
			itemToBeModified->setLabel(labelToBeModified);
		} else if (modifier == MODIFIER_PRIORITY){
			char priorityToBeModified = checkPriority(iter->text);
			itemToBeModified->setPriority(priorityToBeModified);
		} else if (modifier == MODIFIER_COMPLETION){
			bool done = true;
			itemToBeModified->setCompletion(done);
		} else{
			throw MESSAGE_LOGIC + MESSAGE_INVALID_MODIFIER;
		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}
	return modifiedItemPartsForDisplay;
}


char Logic::checkPriority(string priorityToBeModified){
	try{
		if (priorityToBeModified == ACCEPTABLE_PRIORITY_HIGH_1 || priorityToBeModified == ACCEPTABLE_PRIORITY_HIGH_2 || priorityToBeModified == ACCEPTABLE_PRIORITY_HIGH_3){
			return PRIORITY_HIGH;
		} else if (priorityToBeModified == ACCEPTABLE_PRIORITY_MEDIUM_1 || priorityToBeModified == ACCEPTABLE_PRIORITY_MEDIUM_2 || priorityToBeModified == ACCEPTABLE_PRIORITY_MEDIUM_3){
			return PRIORITY_MEDIUM;
		} else if (priorityToBeModified == ACCEPTABLE_PRIORITY_LOW_1 || priorityToBeModified == ACCEPTABLE_PRIORITY_LOW_2 || priorityToBeModified == ACCEPTABLE_PRIORITY_LOW_3){
			return PRIORITY_LOW;
		} else{
			throw MESSAGE_LOGIC + MESSAGE_INVALID_PRIORITY;
		}
	}
	catch (string errorMessage) {
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}
	return PRIORITY_INVALID;
}


DateTime Logic::interpreteDateTime(string infoToBeInterpreted, DateTime existingTimeSetting){
	istringstream inputTime(infoToBeInterpreted);
	int YYYY, MM, DD, hh, mm;
	int YYYY2, MM2, DD2, hh2, mm2;

	YYYY = existingTimeSetting.getYear();
	MM = existingTimeSetting.getMonth();
	DD = existingTimeSetting.getDay();
	hh = existingTimeSetting.getHour();
	mm = existingTimeSetting.getMinute();

	inputTime >> YYYY2 >> MM2 >> DD2 >> hh2 >> mm2;

	//if new time input is user defined, make appropriate changes
	if (YYYY2 != EMPTY_TIME_FIELD){
		YYYY = YYYY2;
	}
	if (MM2 != EMPTY_TIME_FIELD){
		MM = MM2;
	}
	if (DD2 != EMPTY_TIME_FIELD){
		DD = DD2;
	}
	if (hh2 != EMPTY_TIME_FIELD){
		hh = hh2;
	}
	if (mm2 != EMPTY_TIME_FIELD){
		mm = mm2;
	}

	//when user did not specified any dates, set current date
	if (YYYY == EMPTY_TIME_FIELD && YYYY2 == EMPTY_TIME_FIELD && MM == EMPTY_TIME_FIELD && MM2 == EMPTY_TIME_FIELD && DD == EMPTY_TIME_FIELD && DD2 == EMPTY_TIME_FIELD){
		YYYY = getCurrentTime().getYear();
		MM = getCurrentTime().getMonth();
		DD = getCurrentTime().getDay();
	}

	//if user did not specify year, set current year
	if (YYYY == EMPTY_TIME_FIELD && YYYY2 == EMPTY_TIME_FIELD){
		YYYY = getCurrentTime().getYear();
	}
	
	//if user wants to remove the datetime
	if (YYYY2 == TIME_FIELD_REMOVED && MM2 == TIME_FIELD_REMOVED && DD2 == TIME_FIELD_REMOVED && hh2 == TIME_FIELD_REMOVED && mm2 == TIME_FIELD_REMOVED){
		YYYY = EMPTY_TIME_FIELD;
		MM = EMPTY_TIME_FIELD;
		DD = EMPTY_TIME_FIELD;
		hh = EMPTY_TIME_FIELD;
		mm = EMPTY_TIME_FIELD;
	}

	DateTime interpretedDateTime(YYYY, MM, DD, hh, mm);
	return interpretedDateTime;
}


DateTime Logic::getCurrentTime(){
	CTime t = CTime::GetCurrentTime();
	int currentDay = t.GetDay();
	int currentMonth = t.GetMonth();
	int currentYear = t.GetYear();
	int currentHour = t.GetHour();
	int currentMinute = t.GetMinute();
	DateTime currentDateTime(currentYear, currentMonth, currentDay, currentHour, currentMinute);
	return currentDateTime;
}


string Logic::markDone(unsigned int lineIndex){
	try{
		if (isValidLineIndex(lineIndex)){
			changeCompletion(lineIndex, COMMAND_DONE);
			return MESSAGE_TASK + to_string(lineIndex) + MESSAGE_SUCCESSFUL_MARK_DONE;
		} else{
			printInvalidLineIndex();
			throw MESSAGE_LOGIC + INVALID_LINE_INDEX;
		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}
	return INVALID_LINE_INDEX;
}

string Logic::markUndone(unsigned int lineIndex){
	try{
		if (isValidLineIndex(lineIndex)){
			changeCompletion(lineIndex, COMMAND_UNDONE);
			return MESSAGE_TASK + to_string(lineIndex) + MESSAGE_SUCCESSFUL_MARK_UNDONE;
		} else{
			printInvalidLineIndex();
			throw MESSAGE_LOGIC + INVALID_LINE_INDEX;

		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}
	return INVALID_LINE_INDEX;
}

string Logic::changeCompletion(unsigned int lineIndex, string completion){
	assert(lineIndex > SIZE_ZERO);
	Item* retrievedItem;
	retrievedItem = new Item;
	*retrievedItem = _logicSchedule.retrieveItemGivenDisplayVectorIndex(lineIndex);

	bool done;
	try{
		if (completion == COMMAND_DONE){
			done = true;
		} else if (completion == COMMAND_UNDONE){
			done = false;
		} else{
			throw MESSAGE_LOGIC + MESSAGE_INVALID_COMPLETION;

		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
		return MESSAGE_INVALID_COMPLETION;
	}

	retrievedItem->setCompletion(done);
	_logicSchedule.replaceItemGivenDisplayVectorIndex(retrievedItem, lineIndex);
	removeItemPointer(retrievedItem);
	return MESSAGE_SUCCESSFUL_CHANGE_COMPLETION + completion;
}


/////////////////////////////////////
////*SORT TASK RELATED FUNCTIONS*////
/////////////////////////////////////


vector<Item> Logic::sortTask(){
	vector<Item> sortedDisplaySchedule;
	if (_currentFilter == FILTER_ALL){
		sortedDisplaySchedule = resetAndGetDisplaySchedule();
	} else{
		sortedDisplaySchedule = getDisplaySchedule();
	}
	try{
		if (_currentSorting == SORT_NAME){
			sortedDisplaySchedule = _logicSchedule.retrieveDisplayScheduleByItemName();
		} else if (_currentSorting == SORT_PRIORITY){
			sortedDisplaySchedule = _logicSchedule.retrieveDisplayScheduleByPriority();
		} else if (_currentSorting == SORT_COMPLETION){
			sortedDisplaySchedule = _logicSchedule.retrieveDisplayScheduleByCompletionStatus();
		} else if (_currentSorting == SORT_DATE){
			sortedDisplaySchedule = _logicSchedule.retrieveDisplayScheduleByDate();
		} else if (_currentSorting == SORT_LAST_UPDATE){
			sortedDisplaySchedule = _logicSchedule.retrieveDisplayScheduleByLastUpdate();
		} else{
			throw MESSAGE_LOGIC + MESSAGE_INVALID_SORTTYPE;
		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}
	printSchedule(sortedDisplaySchedule);
	return sortedDisplaySchedule;
}


string Logic::changeCurrentSorting(string sortingMethod){
	try{
		if (isValidSortingMethod(sortingMethod)){
			changeCurrentSortingAsUserSpecified(sortingMethod);
			return MESSAGE_SUCCESSFUL_SORT + _currentSorting;
		} else {
			printSortTaskFailed();
			throw MESSAGE_LOGIC + MESSAGE_FAILED_SORT + MESSAGE_INVALID_SORTTYPE;
		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}
	return MESSAGE_FAILED_SORT + MESSAGE_INVALID_SORTTYPE;
}


string Logic::changeCurrentSortingAsUserSpecified(string sortingMethod){
	_currentSorting = sortingMethod;
	printSortTaskSuccessful();
	return MESSAGE_SUCCESSFUL_SORT;
}


//////////////////////////////////
////*FILTER RELATED FUNCTIONS*////
//////////////////////////////////


string Logic::filterTask(string filterToBeImplemented){
	istringstream iss(filterToBeImplemented);
	string filterType;

	iss >> filterType;
	if (filterType == FILTER_COMPLETION){
		bool completion = true;
		filterByCompletion(completion);
	} else if (filterType == FILTER_COMPLETION_UNDONE){
		bool completion = false;
		filterByCompletion(completion);
	} else if (filterType == FILTER_PRIORITY_HIGH || filterType == FILTER_PRIORITY_MEDIUM || filterType == FILTER_PRIORITY_LOW){
		char priorityType = stringConvertToPriorityChar(filterType);
		string returnMessage = filterByPriority(priorityType);
		if (returnMessage == MESSAGE_INVALID_PRIORITY){
			return MESSAGE_FAILED_VIEW + MESSAGE_INVALID_PRIORITY;
		}
	} else if (filterType == FILTER_ALL){
		removeFilter();
	} else if (filterType == FILTER_KEYWORD){
		searchTask();
	} else if (filterType == FILTER_DATE){
		_startEndTime = getStartEndTime(filterToBeImplemented);
		_currentFilter = filterToBeImplemented;
		filterByDate(_startEndTime);
		return MESSAGE_SUCCESSFUL_VIEW + FILTER_DATE;
	} else{
		printInvalidViewOption();
		return MESSAGE_FAILED_VIEW + MESSAGE_INVALID_FILTERTYPE;
	}
	printViewChanged();
	return MESSAGE_SUCCESSFUL_VIEW + _currentFilter;
}

string Logic::filterByDate(START_END_TIME startEndTime){
	_logicSchedule.retrieveDisplayScheduleFilteredByDateTime(_startEndTime.startTime, _startEndTime.endTime);
	return FILTER_DATE;
}

START_END_TIME Logic::getStartEndTime(string infoToBeInterpreted){
	string junk;
	int YYYY, MM, DD, hh, mm;
	istringstream iss(infoToBeInterpreted);
	iss >> junk;
	iss >> YYYY >> MM >> DD >> hh >> mm;
	DateTime startTime = interpretStartEndTime(MODIFIER_START, YYYY, MM, DD, hh, mm);
	iss >> YYYY >> MM >> DD >> hh >> mm;
	DateTime endTime = interpretStartEndTime(MODIFIER_END, YYYY, MM, DD, hh, mm);
	_startEndTime.startTime = startTime;
	_startEndTime.endTime = endTime;
	return _startEndTime;
}

DateTime Logic::interpretStartEndTime(string identifier, int YYYY, int MM, int DD, int hh, int mm){
	if (YYYY == EMPTY_TIME_FIELD){
		YYYY = getCurrentTime().getYear();
	}
	if (MM == EMPTY_TIME_FIELD) {
		MM = getCurrentTime().getMonth();
	}
	if (DD == EMPTY_TIME_FIELD){
		DD = getCurrentTime().getDay();
	}
	if (identifier == MODIFIER_END && hh == EMPTY_TIME_FIELD && mm == EMPTY_TIME_FIELD){
		hh = FINAL_HOUR;
			mm = FINAL_MINUTE;
	}
	cout << YYYY << SPACE_BAR << MM << SPACE_BAR << DD << SPACE_BAR << hh << SPACE_BAR << mm << endl;
	DateTime startEndTime(YYYY, MM, DD, hh, mm);
	return startEndTime;
}

void Logic::clearKeyWordVec(){
	_keywordVec.clear();
	return;
}


string Logic::filterByCompletion(bool completion){
	_logicSchedule.retrieveDisplayScheduleFilteredByCompletion(completion);
	try {
		if (completion == true){
			_currentFilter = FILTER_COMPLETION;
		} else if (completion == false){
			_currentFilter = FILTER_COMPLETION_UNDONE;
		} else{
			throw MESSAGE_LOGIC + MESSAGE_INVALID_COMPLETION;
		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}

	return _currentFilter;
}

char Logic::stringConvertToPriorityChar(string priority){
	_currentFilter = priority;
	try{
		if (priority == FILTER_PRIORITY_HIGH){
			return PRIORITY_HIGH;
		} else if (priority == FILTER_PRIORITY_MEDIUM){
			return PRIORITY_MEDIUM;
		} else if (priority == FILTER_PRIORITY_LOW){
			return PRIORITY_LOW;
		} else {
			throw MESSAGE_LOGIC+ MESSAGE_INVALID_PRIORITY;
		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}
	return PRIORITY_INVALID;

}

string Logic::filterByPriority(char priority){
	try{
		if (priority != PRIORITY_INVALID){
			_logicSchedule.retrieveDisplayScheduleFilteredByPriority(priority);
			return _currentFilter;
		} else {
			throw MESSAGE_LOGIC + MESSAGE_INVALID_PRIORITY;
		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}
	return MESSAGE_INVALID_PRIORITY;
}


string Logic::removeFilter(){
	_currentFilter = FILTER_ALL;
	return _currentFilter;
}


string Logic::modifyKeywordVec(string keyWord){
	convertStringToKeywordVec(keyWord);
	_currentFilter = FILTER_KEYWORD;
	return MESSAGE_TASK_FOUND + keyWord;
}


string Logic::searchTask(){
	for (int lineIndex = SIZE_ZERO; lineIndex < _keywordVec.size(); lineIndex++){
		_logicSchedule.retrieveDisplayScheduleFilteredByKeyword(_keywordVec[lineIndex]);
	}
	try{
		if (getDisplayScheduleSize() == SIZE_ZERO){
			return MESSAGE_NO_TASK_FOUND;
		} else if (getDisplayScheduleSize() > SIZE_ZERO){
			_currentFilter = FILTER_KEYWORD;
			return MESSAGE_TASK_FOUND;
		} else {
			throw MESSAGE_LOGIC + MESSAGE_INVALID_INPUT;
		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}
	return MESSAGE_INVALID_INPUT;
}

string Logic::trimText(string& text) {
	text = trimFront(text);
	text = trimBack(text);
	return MESSAGE_SUCCESS;
}

string Logic::trimFront(string text) {
	unsigned int startIndex = FIRST_INDEX;

	while (startIndex < text.length() && (text[startIndex] == CHAR_SPACE_BAR || text[startIndex] == CHAR_TAB)) {
		startIndex++;
	}
	return text.substr(startIndex);
}

string Logic::trimBack(string text) {
	unsigned int endIndex = text.length();

	while (endIndex > 0 && (text[endIndex - 1] == CHAR_SPACE_BAR || text[endIndex - 1] == CHAR_TAB)) {
		endIndex--;
	}

	return text.substr(FIRST_INDEX, endIndex);
}

/////////////////////////////////////
////*SAVE FILE RELATED FUNCTIONS*////
/////////////////////////////////////


string Logic::changeSavingDirectory(string userInputDirectory){
	string directoryToMake = EMPTY_STRING;
	int truncatePosition;
	if (userInputDirectory == MESSAGE_DEFAULT){
		userInputDirectory = EMPTY_STRING;
	}

	while (userInputDirectory != EMPTY_STRING){
		truncatePosition = userInputDirectory.find_first_of(END_OF_FOLDER_NAME);
		if (truncatePosition != NOT_FOUND){
			directoryToMake = directoryToMake + assignOneFolderToMake(truncatePosition, userInputDirectory);
			userInputDirectory = truncateUserInputDirectory(truncatePosition, userInputDirectory);
		} else{
			directoryToMake = assignLastFolderToMake(userInputDirectory, directoryToMake);
			userInputDirectory = EMPTY_STRING;
		}
		_mkdir(directoryToMake.c_str());
	}
	_directoryToBeSaved = directoryToMake;
	saveBasicInformationToTextFile();
	printChangeSavingDirectorySuccessful();
	return directoryToMake;
}


string Logic::assignOneFolderToMake(int truncatePosition, string userInputDirectory){
	return userInputDirectory.substr(FIRST_INDEX, truncatePosition + 1);
}


string Logic::assignLastFolderToMake(string userInputDirectory, string directoryToMake){
	return  directoryToMake + userInputDirectory;
}


string Logic::truncateUserInputDirectory(int truncatePosition, string userInputDirectory){
	return userInputDirectory.substr(truncatePosition + 1);
}




void Logic::saveBasicInformationToTextFile(){
	ofstream writeFile(TEXTFILE_TO_STORE_DIRECTORY_AND_FILENAME);
	writeFile << _directoryToBeSaved << endl;
	writeFile << _fileNameToBeSaved << endl;
	writeFile << getScheduleSize() << endl;
	writeFile << _nextItemID << endl;
}


string Logic::convertKeywordVecToString(){
	string keywordString = EMPTY_STRING;
	if (_keywordVec.size() != 0){
		for (int i = 0; i < _keywordVec.size(); i++){
			if (i != _keywordVec.size() - 1){
				keywordString = keywordString + _keywordVec[i] + PLUS;
			} else{
				keywordString = keywordString + _keywordVec[i];
			}
		}
	}
	return keywordString;
}

void Logic::convertStringToKeywordVec(string keywordString){
	while (keywordString != EMPTY_STRING){
		int breakPoint = keywordString.find_first_of(PLUS);
		if (breakPoint != NOT_FOUND){
			string tokenisedKeyword = keywordString.substr(FIRST_INDEX, breakPoint);
			trimText(tokenisedKeyword);
			_keywordVec.push_back(tokenisedKeyword);
			keywordString = keywordString.substr(breakPoint + 1);
		} else{
			_keywordVec.push_back(keywordString);
			break;
		}
	}
}

string Logic::getDirectoryAndFileName(){
	if (_directoryToBeSaved == EMPTY_STRING){
		if (_fileNameToBeSaved == EMPTY_STRING){
			_fileNameToBeSaved == DEFAULT_FILENAME;
		}
		return _fileNameToBeSaved;
	} else{
		return _directoryToBeSaved + END_OF_FOLDER_NAME + _fileNameToBeSaved;
	}
}


string Logic::retrieveBasicInformation(){
	try{
		if (isExistingFileInDirectory(TEXTFILE_TO_STORE_DIRECTORY_AND_FILENAME)){
			retrieveBasicInformationFromTextFile();
			return MESSAGE_RETRIEVED_FROM_TEXT_FILE;
		} else {
			//new user or basicinformation textfile is corrupted
			createNewTextFile();
			throw MESSAGE_LOGIC + MESSAGE_FILE_NOT_EXISTING;
		}
	}
	catch (string errorMessage){
		cerr << errorMessage << endl;
		_logicLogger.writeToLogFile(errorMessage);
	}
	return MESSAGE_FILE_NOT_EXISTING;
}


string Logic::retrieveBasicInformationFromTextFile(){
	ifstream readFile(TEXTFILE_TO_STORE_DIRECTORY_AND_FILENAME);
	getline(readFile, _directoryToBeSaved);
	getline(readFile, _fileNameToBeSaved);
	readFile >> _scheduleSize;
	readFile >> _nextItemID;

	cout << _directoryToBeSaved + END_OF_FOLDER_NAME + _fileNameToBeSaved << endl;

	if (_directoryToBeSaved == EMPTY_STRING){
		if (_fileNameToBeSaved == EMPTY_STRING){
			_fileNameToBeSaved == DEFAULT_FILENAME;
		}
		return _fileNameToBeSaved;
	} else{
		return _directoryToBeSaved + END_OF_FOLDER_NAME + _fileNameToBeSaved;
	}
}


string Logic::createNewTextFile(){
	saveBasicInformationToTextFile();
	return _directoryToBeSaved;
}


string Logic::changeSavingFileName(string FileNameToBeSaved){
	_fileNameToBeSaved = FileNameToBeSaved;
	saveBasicInformationToTextFile();
	return FileNameToBeSaved;
}


string Logic::readDataFromFile() {
	if (isExistingFileInDirectory(getDirectoryAndFileName())){
		ifstream readFile(getDirectoryAndFileName());
		for (unsigned int lineNumber = SIZE_ZERO; lineNumber < _scheduleSize; lineNumber++){

			string itemName;
			string description;
			string itemID;
			string junk;
			char priority;
			char label;
			int DD;
			int MM;
			int YYYY;
			int hh;
			int mm;
			unsigned int ID;
			int completionIndicator;
			bool completion = false;
			getline(readFile, itemName);
			getline(readFile, itemID);
			ID = convertToDigit(itemID);
			readFile >> YYYY;
			readFile >> MM;
			readFile >> DD;
			readFile >> hh;
			readFile >> mm;
			DateTime startTime(YYYY, MM, DD, hh, mm);
			readFile >> YYYY;
			readFile >> MM;
			readFile >> DD;
			readFile >> hh;
			readFile >> mm;
			DateTime EndTime(YYYY, MM, DD, hh, mm);
			getline(readFile, junk);
			getline(readFile, description);
			readFile >> priority;
			readFile >> label;
			readFile >> completionIndicator;
			if (completionIndicator != SIZE_ZERO){
				completion = true;
			}
			getline(readFile, junk);
			Item *item;
			item = new Item;
			item->setItemName(itemName);
			item->setItemID(ID);
			item->setStartTime(startTime);
			item->setEndTime(EndTime);
			item->setDescription(description);
			item->setPriority(priority);
			item->setLabel(label);
			item->setCompletion(completion);
			_logicSchedule.addItem(item);
			removeItemPointer(item);
		}
	} else{
		ofstream writeFile(getDirectoryAndFileName());
	}
	_logicSchedule.resetHistory();
	cout << SCHEDULE_RETRIEVED << endl;
	resetAndGetDisplaySchedule();
	sortTask();
	
	return MESSAGE_READFILE_COMPLETE;
}


string Logic::writeDataOntoFile(){
	ofstream writeFile(getDirectoryAndFileName());
	vector<Item> retrievedSchedule = getSchedule();
	for (unsigned int lineNumber = 0; lineNumber < _logicSchedule.getSizeOfSchedule(); lineNumber++){
		Item itemToStore = retrievedSchedule[lineNumber];
		writeFile << itemToStore.getItemName() << endl;
		writeFile << itemToStore.getItemID() << endl;
		writeFile << itemToStore.getStartTime().getYear() << endl;
		writeFile << itemToStore.getStartTime().getMonth() << endl;
		writeFile << itemToStore.getStartTime().getDay() << endl;
		writeFile << itemToStore.getStartTime().getHour() << endl;
		writeFile << itemToStore.getStartTime().getMinute() << endl;
		writeFile << itemToStore.getEndTime().getYear() << endl;
		writeFile << itemToStore.getEndTime().getMonth() << endl;
		writeFile << itemToStore.getEndTime().getDay() << endl;
		writeFile << itemToStore.getEndTime().getHour() << endl;
		writeFile << itemToStore.getEndTime().getMinute() << endl;
		writeFile << itemToStore.getDescription() << endl;
		writeFile << itemToStore.getPriority() << endl;
		writeFile << itemToStore.getLabel() << endl;
		writeFile << itemToStore.getCompletion() << endl;
	}
	saveBasicInformationToTextFile();
	return MESSAGE_WRITEFILE_COMPLETE;
}



/////////////////
////*GETTERS*////
/////////////////


vector<Item> Logic::getSchedule(){
	return _logicSchedule.retrieveSchedule();
}


vector<Item> Logic::resetDisplaySchedule(){
	_logicSchedule.resetDisplaySchedule();
	return getDisplaySchedule();
}


vector<Item> Logic::getDisplaySchedule(){
	return _logicSchedule.retrieveDisplaySchedule();
}


vector<Item> Logic::resetAndGetDisplaySchedule(){
	resetDisplaySchedule();
	filterTask(_currentFilter);
	return getDisplaySchedule();
}


unsigned int Logic::getScheduleSize(){
	_scheduleSize = _logicSchedule.getSizeOfSchedule();
	return _scheduleSize;
}


unsigned int Logic::getDisplayScheduleSize(){
	return _logicSchedule.getSizeOfDisplaySchedule();
}


string Logic::getErrorList(ItemVerification verifier){

	list<string> errorList = verifier.getItemVerificationErrors();
	list<string>::iterator iter;
	string errorString = EMPTY_STRING;
	for (iter = errorList.begin(); iter != errorList.end(); ++iter){
		errorString = errorString + *iter + SPACE_BAR;
	}
	return errorString;
}


///////////////////////////
////*BOOLEAN FUNCTIONS*////
///////////////////////////


bool Logic::isExistingFileInDirectory(string directoryAndFileName) {
	ifstream infile(directoryAndFileName);
	return infile.good();
}


bool Logic::isValidSortingMethod(string itemInformation){
	if (itemInformation == SORT_NAME || itemInformation == SORT_COMPLETION || itemInformation == SORT_DATE ||
		itemInformation == SORT_LAST_UPDATE || itemInformation == SORT_PRIORITY){
		return true;
	} else{
		return false;
	}
}


bool Logic::isValidLineIndex(unsigned int lineIndexToBeChecked){
	if (getDisplayScheduleSize() >= lineIndexToBeChecked && lineIndexToBeChecked > SIZE_ZERO){
		return true;
	} else{
		return false;
	}
}



	// End of segment: C:\Users\SKR\Documents\main\iLogic\Logic.cpp





	/**
	 * origin: C:\Users\SKR\Documents\main\iLogic\Logic.h
	 */

//Coder : Yu Young Bin

#pragma once

#ifndef LOGIC_H
#define LOGIC_H

#include "..\iStorage\Schedule.h"
#include "..\iStorage\Item.h"
#include "..\iParser\iParser.h"
#include "..\iLogic\ItemVerification.h"
#include "..\iPlanner Log\Log.h"
#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <cctype>
#include <algorithm>
#include <direct.h>
#include <atltime.h>
using namespace std;

//structure return to UI
//return message and display vector
struct MESSAGE_AND_SCHEDULE {
	string message;
	vector<Item> displaySchedule;
};

//structure used for view date
struct START_END_TIME{
	DateTime startTime;
	DateTime endTime;
};

class Logic
{
private:
	Schedule _logicSchedule;
	iParser _logicParser;
	unsigned int _nextItemID;
	unsigned int _scheduleSize;
	string _directoryToBeSaved;
	string _fileNameToBeSaved;
	string _currentSorting;
	string _currentFilter;
	vector<string> _keywordVec;
	START_END_TIME _startEndTime;
	Log _logicLogger;

	//used strings for UI display
	static const string MESSAGE_SUCCESS;
	static const string MESSAGE_INVALID_INPUT;
	static const string MESSAGE_INVALID_INPUT_FOR_DELETE;
	static const string COMMAND_ADD;
	static const string COMMAND_DELETE;
	static const string COMMAND_EDIT;
	static const string COMMAND_UNDO;
	static const string COMMAND_SORT;
	static const string COMMAND_SEARCH;
	static const string COMMAND_VIEW;
	static const string COMMAND_DONE;
	static const string COMMAND_UNDONE;
	static const string COMMAND_SAVE;
	static const string COMMAND_EXIT;
	static const string COMMAND_CLEAR;
	static const string MODIFIER_NAME;
	static const string MODIFIER_START;
	static const string MODIFIER_END;
	static const string MODIFIER_DESCRIPTION;
	static const string MODIFIER_LABEL;
	static const string MODIFIER_PRIORITY;
	static const string MODIFIER_COMPLETION;
	static const string SORT_NAME;
	static const string SORT_DATE;
	static const string SORT_PRIORITY;
	static const string SORT_COMPLETION;
	static const string SORT_LAST_UPDATE;
	static const string FILTER_COMPLETION;
	static const string FILTER_COMPLETION_UNDONE;
	static const string FILTER_KEYWORD;
	static const string FILTER_PRIORITY_HIGH;
	static const string FILTER_PRIORITY_MEDIUM;
	static const string FILTER_PRIORITY_LOW;
	static const string FILTER_LABEL;
	static const string FILTER_ALL;
	static const string FILTER_DATE;

	static const string ACCEPTABLE_PRIORITY_HIGH_1;
	static const string ACCEPTABLE_PRIORITY_HIGH_2;
	static const string ACCEPTABLE_PRIORITY_HIGH_3;
	static const string ACCEPTABLE_PRIORITY_MEDIUM_1;
	static const string ACCEPTABLE_PRIORITY_MEDIUM_2;
	static const string ACCEPTABLE_PRIORITY_MEDIUM_3;
	static const string ACCEPTABLE_PRIORITY_LOW_1;
	static const string ACCEPTABLE_PRIORITY_LOW_2;
	static const string ACCEPTABLE_PRIORITY_LOW_3;

	static const char PRIORITY_HIGH;
	static const char PRIORITY_MEDIUM;
	static const char PRIORITY_LOW;
	static const char PRIORITY_INVALID;


	static char buffer[300];
	static const string ASSIGNED_PRIORITY;
	static const string ASSIGNED_LABEL;
	static const string ASSIGNED_START_TIME;
	static const string ASSIGNED_END_TIME;
	static const string ASSIGNED_NAME;
	static const string ASSIGNED_DESCRIPTION;
	static const string TEXTFILE_TO_STORE_DIRECTORY_AND_FILENAME;
	static const string DEFAULT_FILENAME;
	static const string DEFAULT_SORTING;
	static const string MESSAGE_TASK;
	static const string MESSAGE_SUCCESSFUL_ADD;
	static const string MESSAGE_SUCCESSFUL_DELETE;
	static const string MESSAGE_SUCCESSFUL_EDIT;
	static const string MESSAGE_SUCCESSFUL_SORT;
	static const string MESSAGE_SUCCESSFUL_VIEW;
	static const string MESSAGE_SUCCESSFUL_SAVE;
	static const string MESSAGE_SUCCESSFUL_UNDO;
	static const string MESSAGE_SUCCESSFUL_MARK_DONE;
	static const string MESSAGE_SUCCESSFUL_MARK_UNDONE;
	static const string MESSAGE_SUCCESSFUL_CHANGE_COMPLETION;
	static const string MESSAGE_CLEAR;
	static const string MESSAGE_RETRIEVED_FROM_TEXT_FILE;
	static const string MESSAGE_FILE_NOT_EXISTING;
	static const string MESSAGE_FAILED_ADD;
	static const string MESSAGE_FAILED_DELETE;
	static const string MESSAGE_FAILED_EDIT;
	static const string MESSAGE_FAILED_VIEW;
	static const string MESSAGE_FAILED_SAVE;
	static const string MESSAGE_FAILED_UNDO;
	static const string MESSAGE_FAILED_SORT;
	static const string MESSAGE_INVALID_INDEX;
	static const string MESSAGE_INVALID_PRIORITY;
	static const string MESSAGE_INVALID_SORTTYPE;
	static const string MESSAGE_INVALID_FILTERTYPE;
	static const string MESSAGE_INVALID_MODIFIER;
	static const string MESSAGE_INVALID_COMPLETION;
	static const string MESSAGE_NO_TASK_FOUND;
	static const string MESSAGE_TASK_FOUND;
	static const string MESSAGE_UNABLE_TO_UNDO;
	static const string MESSAGE_READFILE_COMPLETE;
	static const string MESSAGE_WRITEFILE_COMPLETE;
	static const string MESSAGE_LOGIC;
	static const string MESSAGE_DEFAULT;
	static const string END_OF_FOLDER_NAME;
	static const string PLUS;
	static const string EMPTY_STRING;
	static const string SPACE_BAR;
	static const char CHAR_SPACE_BAR;
	static const char CHAR_TAB;

	//used to avoid using magic numbers
	static const unsigned int FIRST_INDEX;
	static const unsigned int SIZE_ZERO;
	static const unsigned int SIZE_INVALID;
	static const unsigned int NOT_FOUND;
	static const unsigned int EMPTY_TIME_FIELD;
	static const unsigned int TIME_FIELD_REMOVED;
	static const unsigned int INITIAL_ITEM_ID;
	static const unsigned int FIRST_HOUR;
	static const unsigned int FIRST_MINUTE;
	static const unsigned int FINAL_HOUR;
	static const unsigned int FINAL_MINUTE;
	static const int ZERO_INDEX;
	static const unsigned int DEFAULT_ITEM_ID;


	//Strings used for CLI prints
	static const string SCHEDULE_HEAD;
	static const string SCHEDULE_END;
	static const string ADD_TASK_SUCCESSFUL;
	static const string DELETE_TASK_SUCCESSFUL;
	static const string EDIT_TASK_SUCCESSFUL;
	static const string SORT_TASK_SUCCESSFUL;
	static const string MARK_DONE_SUCCESSFUL;
	static const string SCHEDULE_RETRIEVED;
	static const string ADD_TASK_FAILED;
	static const string DELETE_TASK_FAILED;
	static const string EDIT_TASK_FAILED;
	static const string INVALID_LINE_INDEX;
	static const string SORT_TASK_FAILED;




public:
	Logic();
	~Logic();


	/////////////////////////
	////*PRINT FUNCTIONS*////
	/////////////////////////

	//Print functions are used for command line interface
	//for debugging purpose
	//for a better visualisation of UI 
	void printSchedule(vector<Item> retrievedDisplaySchedule);
	void printItem(Item itemToBePrinted);
	void printAddTaskSuccessful(string itemInformationToBePrinted);
	void printDeleteTaskSuccessful(int lineNumberToBeDeleted);
	void printEditTaskSuccessful(int lineNumberToBeEdited);
	void printSortTaskSuccessful();
	void printMarkDoneSuccessful(unsigned int lineIndex);
	void printViewChanged();
	void printUndo();
	void printAddTaskFailed(ItemVerification verifier);
	void printDeleteTaskFailed();
	void printEditTaskInvalidLineIndex();
	void printEditTaskInvalidItemParts(ItemVerification verifier);
	void printInvalidInput();
	void printSortTaskFailed();
	void printInvalidLineIndex();
	void printInvalidViewOption();
	void printChangeSavingDirectorySuccessful();



	////////////////////////
	////*MAIN FUNCTIONS*////
	////////////////////////


	//takes in the user input and initiate the action according to the command
	//specified by the user
	//Pre : takes in a whole line of user input
	//Post : returns a message whether each command was executed successfully and the display vector to pass to UI
	MESSAGE_AND_SCHEDULE initiateCommandAction(string input);


	//create a structure that consists of message of success or failure of each command
	//and display vector
	//pre : takes in a string of message 
	//post : returns a MESSAGE_AND_SCHEDULE object created
	MESSAGE_AND_SCHEDULE Logic::returnUserDisplayInformation(string returnMessage);


	//calls for parser and get parsed info of the user input
	//pre : takes in parser and a line of user input
	//post : returns a list of command and text of the user input
	list<COMMAND_AND_TEXT> getParseInfo(iParser parser, string input);



	////////////////////////////////////
	////*ADD TASK RELATED FUNCTIONS*////
	////////////////////////////////////


	//add new Item in the Schedule, add task sets ItemID, which is a fixed number assigned to each Item
	//for identification purpose
	//Pre: takes in the parse info given by the parser and execute addTask
	//post:returns Success or Failure message
	string addTask(list<COMMAND_AND_TEXT> parseInfoToBeProcessed);


	//adds Item to schedule once the item is valid
	//Pre : takes in valid item to be added to storage
	//post : returns a message of successful addition
	string Logic::addItemToSchedule(Item* newItemToBeAdded);


	//set an item name and id for a new item created
	//Pre : takes in the item pointer that ID and name should be assigned and the name that user specified
	//Post : none
	void setItemNameAndIDForNewItem(Item *newItem, list<COMMAND_AND_TEXT> parseInfoToBeProcessed);


	//ItemID starts from 1, everytime when addTask is called, nextItemID increases by 1
	//Pre: None
	//Post : returns nextItemID
	unsigned int increaseItemID();


	//remove pointer object in order to prevent memory leakage
	//pre : takes in an item pointer
	//post : none
	void removeItemPointer(Item* itemPointer);



	///////////////////////////////////////
	////*DELETE TASK RELATED FUNCTIONS*////
	///////////////////////////////////////


	//Delete Item from the schedule, given a valid line index to be deleted is provided
	//Pre: takes in the parse info given by the parser and execute deleteTask
	//post:returns Success or Failure message
	string deleteTask(unsigned int lineIndexToBeDeleted);


	//takes in valid line number and execute deletion from the schedule
	//pre : takes in the valid line index
	//post : returns a message delete successful
	string deleteItemFromSchedule(unsigned int lineIndexToBeDeleted);


	//converts a string into an int
	//pre : takes in a string
	//post : returns an int
	int convertToDigit(string text);


	//Undo previous action
	//pre : none
	//post : returns a message whether undo is executed successfully
	string undoPreviousAction();


	/////////////////////////////////////
	////*EDIT TASK RELATED FUNCTIONS*////
	/////////////////////////////////////


	//modify the item, if valid line index and parse info are passed.
	//Pre: takes in the lineIndex and the parse info given by the parser and execute editTask
	//post: returns Success or Failure message
	string editTask(list<COMMAND_AND_TEXT>, unsigned int lineIndexToBeEdited);


	//if Item to be modified is valid and line index is valid, replace the item from the schedule
	//pre : takes in valid item pointer, and valid line index
	//post : returns message edit successful
	string replaceItemInSchedule(Item* editedItemToBeReplaced, unsigned int lineIndexToBeEdited);


	//modifies an item, specified by the parse info
	//Pre: takes in an item to be modified, and a parse info list to execute the modification
	//Post : returns the string of itemparts that is modified
	string modifyItem(list<COMMAND_AND_TEXT> parseInfoToBeprocessed, Item* itemToBeModified);


	//modifies each part of the item, specified by the parse info
	//Pre : takes in the iterator of the Command and text list, and the item pointer to be modified
	//post : returns the part that is modified
	string modifyItemParts(list<COMMAND_AND_TEXT>::iterator iter, Item* itemToBeModified, string& modifiedItemPartsForDisplay);


	//changes completion of the specified line index if line index given is valid
	//pre : takes in line index
	//post : returns a message whether mark done is successful or not
	string markDone(unsigned int lineIndex);
	string markUndone(unsigned int lineIndex);

	//valid line index given, changes the completion of the item to done
	//pre : takes in valid line index
	//post : returns a message of successful change
	string changeCompletion(unsigned int lineIndex, string completion);

	//Parser returns a whole string of dateTime data
	//interpreteDateTime switches the stringed input into 5 integers
	//and createDateTime create a DateTime object based on the 5 integers given
	//Pre : takes in a string, usually the text part of the COMMAND_AND_TEXT parsed by the parser
	//Post : returns a dateTime object created
	DateTime interpreteDateTime(string infoToBeInterpreted, DateTime existingTimeSetting);
	DateTime createDateTime(int DD, int MM, int YYYY, int hh, int mm);


	//gets current time and convert it to a DateTime object
	//pre : none
	//post : dateTime object of the current time
	DateTime getCurrentTime();


	//checks whether priority specified by the user is valid
	//pre : takes in a string of text input by the user
	//post : interprets and returns a priority charactor (H,M,L) 
	char checkPriority(string priorityToBeModified);




	/////////////////////////////////////
	////*SORT TASK RELATED FUNCTIONS*////
	/////////////////////////////////////


	//sorting can be done by - last update, name, priority, date, completion
	//sorting method is stored in _currentSorting
	//Pre: none
	//Post: returns the Display vector of Items
	vector<Item> sortTask();


	//changes current Sorting method if sorting method specified by the user is valid.
	//display schedule will be sorted according to the current sorting method
	//everytime a command is executed.
	//Pre : takes in a string that consists of sorting method to be changed
	//post : returns current sorting method
	string changeCurrentSorting(string sortingMethod);


	//valid sorting method is specified and changes current Sorting method
	//Pre : takes in a string that consists of sorting method to be changed
	//post : returns current sorting method
	string changeCurrentSortingAsUserSpecified(string sortingMethod);



	//////////////////////////////////
	////*FILTER RELATED FUNCTIONS*////
	//////////////////////////////////


	//changes the filter of the display vector as specified by the user
	//Available filters : completion, priority, no filter
	//pre : takes in a string of filter
	//post : returns a message whether filter is successfully implemented
	string filterTask(string filterToBeImplemented);
	string filterByCompletion(bool completion);
	string filterByPriority(char priority);
	string filterByDate(START_END_TIME);
	string removeFilter();


	//searches for a keyword from item name and item description of all the items in the schedule
	//pre : takes in a key word to search
	//post : returns whether item(s) can be found
	string modifyKeywordVec(string keyWord);
	string searchTask();
	void clearKeyWordVec();

	//convert a string to a priority charactor (H,M,L)
	//Pre: takes in a string that contains information on priority
	//post: returns a priority charactor(H,M,L) Invalid priority (E)
	char stringConvertToPriorityChar(string priority);


	//takes in a string and trims the empty space front and back of it
	//Pre : takes in a string
	//Post : trimmed string
	string trimText(string& text);
	string trimBack(string text);
	string trimFront(string text);


	/////////////////
	////*GETTERS*////
	/////////////////


	//Initiate the update on the display schedule in storage
	//and get or print the display schedule
	//Pre : none
	//Post : returns display schedule
	vector<Item> resetDisplaySchedule();
	vector<Item> resetAndGetDisplaySchedule();


	//does not reset but retrieves current state of the display schedule (for the filtered view)
	//pre : none
	//post : returns display schedule
	vector<Item> getDisplaySchedule();


	//retrieves the schedule(only used for saving purpose)
	//pre : none
	//post : returns schedule
	vector<Item> getSchedule();


	//retrieves display schedule/ schedule size
	//Pre : none
	//Post : returns size of the schedule
	unsigned int getScheduleSize();
	unsigned int getDisplayScheduleSize();


	//get a list of errors that user made
	//pre : takes in the verifier to check
	//post : returns a  string that contains error lists
	string getErrorList(ItemVerification verifier);


	//gets start and end time for the view date option
	//takes in 10 integers and turn them into a start_END_TIME structure
	//Pre : Takes in a string containing 10 integers
	//Post : returns a START_END_TIME structure
	START_END_TIME getStartEndTime(string infoToBeInterpreted);
	DateTime interpretStartEndTime(string identifier, int YYYY, int MM, int DD, int hh, int mm);


	/////////////////////////////////////
	////*SAVE FILE RELATED FUNCTIONS*////
	/////////////////////////////////////


	//changes directory and name of the saving text file
	//Pre : takes in directory and file name specified by the user
	//post : returns directory and file name
	string changeSavingDirectory(string directoryToBeSaved);
	string changeSavingFileName(string FileNameToBeSaved);


	//makes folder and truncate the directory 
	//pre : takes in the directory to make and truncate when '/' is found.
	//		truncate the string and make folder 
	//post : return the truncated directory
	string assignOneFolderToMake(int truncatePosition, string userInputDirectory);
	string assignLastFolderToMake(string userInputDirectory, string directoryToMake);
	string truncateUserInputDirectory(int truncatePosition, string userInputDirectory);


	//retrieves the directory and filename of the save file
	//pre : none
	//post : returns directory + filename
	string getDirectoryAndFileName();
	string convertKeywordVecToString();
	void convertStringToKeywordVec(string keywordString);


	//save basic information in to basicinformation.txt file
	//basic information include :
	//directory, filename, schedulesize, sorting method, last item id used, filter
	//pre : none
	//post : none
	void saveBasicInformationToTextFile();


	//retrieves basic information if basicinformation.txt file exists
	//create new basicinformation.txt file for a new user or file is corrupted or accidentally deleted
	//pre : none
	//post : returns a message to indicate whether textfile exists
	string retrieveBasicInformation();
	string retrieveBasicInformationFromTextFile();
	string createNewTextFile();


	//store schedule and retrieve schedule from text file
	//pre : none
	//post : none
	string readDataFromFile();
	string writeDataOntoFile();



	///////////////////////////
	////*BOOLEAN FUNCTIONS*////
	///////////////////////////


	//boolean functions to check the validity of each components
	//pre : takes in appropriate parameters
	//post : true or false
	bool isValidSortingMethod(string itemInformation);
	bool isValidLineIndex(unsigned int lineIndexToBeChecked);
	bool isExistingFileInDirectory(string directoryAndFileName);
	bool isEmptyStartAndEndTime();

};

#endif

	// End of segment: C:\Users\SKR\Documents\main\iLogic\Logic.h





	/**
	 * origin: C:\Users\SKR\Documents\main\iLogicTest\iLogicTest.cpp
	 */

//Coder : Yu Young Bin

#include "stdafx.h"
#include "CppUnitTest.h"
#include "Logic.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace iLogicTest {
	TEST_CLASS(AddTaskTest) {
public:

	TEST_METHOD(AddTaskTest1) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add one item with valid name and priority*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		string message = testLogic.addTask(testParseInfo);
		string expectedMessage = "Task added to schedule : Young Bin";
		Assert::AreEqual(expectedMessage, message);
	}

	TEST_METHOD(AddTaskTest2) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add one item with valid name and description*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "HAHA";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);

		string message = testLogic.addTask(testParseInfo);
		string expectedMessage = "Task added to schedule : Young Bin";
		Assert::AreEqual(expectedMessage, message);
	}

	TEST_METHOD(AddTaskTest3) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*add one item with valid start time*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);

		string message = testLogic.addTask(testParseInfo);
		string expectedMessage = "Task added to schedule : Young Bin";
		Assert::AreEqual(expectedMessage, message);
	}


	TEST_METHOD(AddTaskTest4) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*add one item with valid start time*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin is testing";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);

		string message = testLogic.addTask(testParseInfo);
		string expectedMessage = "Task added to schedule : Young Bin is testing";
		Assert::AreEqual(expectedMessage, message);
		testParseInfo.clear();

		/*add one item with invalid start time*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin is testing second item";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "999999 99 992 9999 999";
		testParseInfo.push_back(testCommandAndText);
		string expectedAddMessage = "failed_add";
		try{
			testLogic.addTask(testParseInfo);
		}
		catch (string actualMessage){
			Assert::AreEqual(expectedMessage, actualMessage);
		}


	}




	TEST_METHOD(AddTaskTest6) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*add one item with valid Start and end time*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);

		testCommandAndText.command = "start";
		testCommandAndText.text = "1111 12 1 -1 -1";

		testCommandAndText.command = "end";
		testCommandAndText.text = "1222 12 12 -1 -1";
		testParseInfo.push_back(testCommandAndText);

		string message = testLogic.addTask(testParseInfo);
		string expectedMessage = "Task added to schedule : Young Bin";
		Assert::AreEqual(expectedMessage, message);
	}

	TEST_METHOD(AddTaskTest7) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*add one item with invalid Start and end time*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);

		testCommandAndText.command = "start";
		testCommandAndText.text = "9999 9999 9999 9999 9999";

		testCommandAndText.command = "end";
		testCommandAndText.text = "9999 9999 9999 9999 9999";
		testParseInfo.push_back(testCommandAndText);

		string message = testLogic.addTask(testParseInfo);
		string expectedMessage = "Unable to add task : Invalid End Date/TIME ";
		Assert::AreEqual(expectedMessage, message);
	}
	};


	TEST_CLASS(DeleteTaskTest) {
public:

	TEST_METHOD(DeleteTaskTest1) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();
		/*Delete the last line , line 5*/
		unsigned int lineIndexToBeDeleted = 5;
		string expectedDeleteMessage1 = "Task is deleted from schedule";
		string actualDeleteMessage1 = testLogic.deleteTask(lineIndexToBeDeleted);
		Assert::AreEqual(expectedDeleteMessage1, actualDeleteMessage1);

		testLogic.resetAndGetDisplaySchedule();
		/*Delete line 5, which does not exist*/
		try{
			testLogic.deleteTask(lineIndexToBeDeleted);
		}
		catch (string actualDeleteMessage2) {
			string expectedDeleteMessage2 = "Unable to delete task : Invalid index";
			Assert::AreEqual(expectedDeleteMessage2, actualDeleteMessage2);
		}
	}

	TEST_METHOD(DeleteTaskTest2) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();


		testLogic.resetAndGetDisplaySchedule();

		/*Delete the first line*/
		unsigned int lineIndexToBeDeleted = 1;
		string expectedDeleteMessage1 = "Task is deleted from schedule";
		string actualDeleteMessage1 = testLogic.deleteTask(lineIndexToBeDeleted);
		Assert::AreEqual(expectedDeleteMessage1, actualDeleteMessage1);

		testLogic.resetAndGetDisplaySchedule();
		/*Delete the first line*/
		string expectedDeleteMessage2 = "Task is deleted from schedule";
		string actualDeleteMessage2 = testLogic.deleteTask(lineIndexToBeDeleted);
		Assert::AreEqual(expectedDeleteMessage2, actualDeleteMessage2);

	}

	TEST_METHOD(DeleteTaskTest3) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();

		/*delete within the boundary*/
		unsigned int lineIndexToBeDeleted = 2;
		string expectedDeleteMessage1 = "Task is deleted from schedule";
		string actualDeleteMessage1 = testLogic.deleteTask(lineIndexToBeDeleted);
		Assert::AreEqual(expectedDeleteMessage1, actualDeleteMessage1);

		testLogic.resetAndGetDisplaySchedule();
		/*delete within the boundary*/
		string expectedDeleteMessage2 = "Task is deleted from schedule";
		string actualDeleteMessage2 = testLogic.deleteTask(lineIndexToBeDeleted);
		Assert::AreEqual(expectedDeleteMessage2, actualDeleteMessage2);

		testLogic.resetAndGetDisplaySchedule();
		/*delete line index greater than schedulesize*/
		try{
			testLogic.deleteTask(lineIndexToBeDeleted);
		}
		catch (string actualDeleteMessage3) {
			string expectedDeleteMessage3 = "Unable to delete task : Invalid index";
			Assert::AreEqual(expectedDeleteMessage3, actualDeleteMessage3);
		}
	}

	TEST_METHOD(DeleteTaskTest4) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();


		unsigned int lineIndexToBeDeleted = 17;

		testLogic.resetAndGetDisplaySchedule();
		/*delete line index greater than schedulesize*/
		try{
			testLogic.deleteTask(lineIndexToBeDeleted);
		}
		catch (string actualDeleteMessage3) {
			string expectedDeleteMessage3 = "Unable to delete task : Invalid index";
			Assert::AreEqual(expectedDeleteMessage3, actualDeleteMessage3);
		}
	}
	};

	TEST_CLASS(SortTaskTest) {
public:

	TEST_METHOD(SortTaskByName) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();

		/*sort by "name", valid sorting*/
		testLogic.changeCurrentSorting("name");
		testLogic.sortTask();
		vector<Item> retrievedSchedule = testLogic.getDisplaySchedule();

		string expectedItemName1 = "TEST";
		string expectedItemName2 = "TEST2";
		string expectedItemName3 = "TEST3";
		string expectedItemName4 = "TEST4";
		string expectedItemName5 = "Young Bin";

		string actualItemName1 = retrievedSchedule[0].getItemName();
		string actualItemName2 = retrievedSchedule[1].getItemName();
		string actualItemName3 = retrievedSchedule[2].getItemName();
		string actualItemName4 = retrievedSchedule[3].getItemName();
		string actualItemName5 = retrievedSchedule[4].getItemName();

		Assert::AreEqual(expectedItemName1, actualItemName1);
		Assert::AreEqual(expectedItemName2, actualItemName2);
		Assert::AreEqual(expectedItemName3, actualItemName3);
		Assert::AreEqual(expectedItemName4, actualItemName4);
		Assert::AreEqual(expectedItemName5, actualItemName5);
	}

	TEST_METHOD(SortTaskByDate) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();

		/*sort by "date", valid sorting*/
		testLogic.changeCurrentSorting("date");
		vector<Item> retrievedSchedule = testLogic.getDisplaySchedule();

		string expectedItemName1 = "Young Bin";
		string expectedItemName2 = "TEST";
		string expectedItemName3 = "TEST2";
		string expectedItemName4 = "TEST3";
		string expectedItemName5 = "TEST4";

		string actualItemName1 = retrievedSchedule[0].getItemName();
		string actualItemName2 = retrievedSchedule[1].getItemName();
		string actualItemName3 = retrievedSchedule[2].getItemName();
		string actualItemName4 = retrievedSchedule[3].getItemName();
		string actualItemName5 = retrievedSchedule[4].getItemName();

		Assert::AreEqual(expectedItemName1, actualItemName1);
		Assert::AreEqual(expectedItemName2, actualItemName2);
		Assert::AreEqual(expectedItemName3, actualItemName3);
		Assert::AreEqual(expectedItemName4, actualItemName4);
		Assert::AreEqual(expectedItemName5, actualItemName5);
	}

	TEST_METHOD(SortTaskByPriority) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "L";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();

		/*sort by "priority", valid sorting */
		testLogic.changeCurrentSorting("priority");
		vector<Item> retrievedSchedule = testLogic.getDisplaySchedule();

		string expectedItemName1 = "Young Bin";
		string expectedItemName2 = "TEST";
		string expectedItemName3 = "TEST2";
		string expectedItemName4 = "TEST3";
		string expectedItemName5 = "TEST4";

		string actualItemName1 = retrievedSchedule[0].getItemName();
		string actualItemName2 = retrievedSchedule[1].getItemName();
		string actualItemName3 = retrievedSchedule[2].getItemName();
		string actualItemName4 = retrievedSchedule[3].getItemName();
		string actualItemName5 = retrievedSchedule[4].getItemName();

		Assert::AreEqual(expectedItemName1, actualItemName1);
		Assert::AreEqual(expectedItemName2, actualItemName2);
		Assert::AreEqual(expectedItemName3, actualItemName3);
		Assert::AreEqual(expectedItemName4, actualItemName4);
		Assert::AreEqual(expectedItemName5, actualItemName5);
	}

	TEST_METHOD(SortTaskINVALID) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "L";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();

		/*sort by "INVALIDDDDDDDDD", invalid sorting */
		string expectedMessage = "Unable to change sorting : Invalid sort type";
		string actualMessage = testLogic.changeCurrentSorting("INVALIDDDDDDDDD");
		Assert::AreEqual(expectedMessage, actualMessage);
	}

	};

	TEST_CLASS(EditTaskTest) {
public:
	TEST_METHOD(EditTaskTest1) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "L";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();

		/*EDIT VALID LINE WITH VALID MODIFIER*/
		testCommandAndText.command = "edit";
		testCommandAndText.text = "1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "TEST DESCRIPTION";
		testParseInfo.push_back(testCommandAndText);
		string message = testLogic.editTask(testParseInfo, 1);

		Assert::AreEqual((string) "Task 1 is edited : description ", message);
		vector<Item> retrievedSchedule = testLogic.getDisplaySchedule();
	}

	TEST_METHOD(EditTaskTest2) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "L";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();

		/*EDIT VALID LINE WITH INVALID MODIFIER*/
		testCommandAndText.command = "edit";
		testCommandAndText.text = "8";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "TESTDESCRIPTION";
		testParseInfo.push_back(testCommandAndText);
		string message = testLogic.editTask(testParseInfo, 8);

		Assert::AreEqual((string) "Unable to edit task : Invalid index", message);
	}
	};

	TEST_CLASS(ChangingSaveDirectoryTest) {
public:

	TEST_METHOD(savingDirectoryTest1)
	{
		Logic testLogic;
		string testDirectory = "c:/Youngbin'sTest/Haha";

		string expectedSavingDirectory = "c:/Youngbin'sTest/Haha";
		string actualSavingDirectory = testLogic.changeSavingDirectory(testDirectory);
		Assert::AreEqual(expectedSavingDirectory, actualSavingDirectory);

	}



	};

	TEST_CLASS(ChangeCompletionTest) {
public:
	TEST_METHOD(MarkDoneTest1) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "L";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();

		unsigned int lineIndex = 2;
		string expectedMessage = "Task 2 is completed";
		string actualMessage = testLogic.markDone(lineIndex);

		Assert::AreEqual(expectedMessage, actualMessage);

	}


	TEST_METHOD(MarkUndoneTest1) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "L";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();

		unsigned int lineIndex = 2;
		string expectedMessage = "Task 2 is undone";
		string actualMessage = testLogic.markUndone(lineIndex);

		Assert::AreEqual(expectedMessage, actualMessage);

	}

	TEST_METHOD(MarkDoneUndoneTest1) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "L";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();


		unsigned int lineIndex = 2;
		string expectedMessage = "Task 2 is completed";
		string actualMessage = testLogic.markDone(lineIndex);
		Assert::AreEqual(expectedMessage, actualMessage);

		expectedMessage = "Task 2 is undone";
		actualMessage = testLogic.markUndone(lineIndex);
		Assert::AreEqual(expectedMessage, actualMessage);
	}

	TEST_METHOD(MarkDoneUndoneTest2) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "L";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();


		unsigned int lineIndex = 2;
		string expectedMessage = "Task 2 is completed";
		string actualMessage = testLogic.markDone(lineIndex);
		Assert::AreEqual(expectedMessage, actualMessage);

		lineIndex = 3;
		expectedMessage = "Task 3 is undone";
		actualMessage = testLogic.markUndone(lineIndex);
		Assert::AreEqual(expectedMessage, actualMessage);
	}


	};


	TEST_CLASS(UndoTest) {
public:
	TEST_METHOD(UndoTest1) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "L";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();

		string expectedMessage = "Last action reversed";
		string actualMessage = testLogic.undoPreviousAction();
		Assert::AreEqual(expectedMessage, actualMessage);
		expectedMessage = "Last action reversed";
		actualMessage = testLogic.undoPreviousAction();
		Assert::AreEqual(expectedMessage, actualMessage);
		expectedMessage = "Last action reversed";
		actualMessage = testLogic.undoPreviousAction();
		Assert::AreEqual(expectedMessage, actualMessage);
		expectedMessage = "Last action reversed";
		actualMessage = testLogic.undoPreviousAction();
		Assert::AreEqual(expectedMessage, actualMessage);
		expectedMessage = "Last action reversed";
		actualMessage = testLogic.undoPreviousAction();
		Assert::AreEqual(expectedMessage, actualMessage);
		expectedMessage = "Unable to undo last action";
		actualMessage = testLogic.undoPreviousAction();
		Assert::AreEqual(expectedMessage, actualMessage);
	}
	};

	TEST_CLASS(FilterTest) {
public:
	TEST_METHOD(FilterTest1) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "L";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();

		/*filter by completion*/
		bool done = true;
		string expectedMessage = "done";
		string actualMessage = testLogic.filterByCompletion(done);
		Assert::AreEqual(expectedMessage, actualMessage);

		done = false;
		expectedMessage = "undone";
		actualMessage = testLogic.filterByCompletion(done);
		Assert::AreEqual(expectedMessage, actualMessage);

		expectedMessage = "all";
		actualMessage = testLogic.removeFilter();

	}

	TEST_METHOD(FilterTest2) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "L";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();

		/*filter by date*/
		string date = "date 11 11 2015 00 00 12 12 2015 00 00";
		START_END_TIME testStartEnd = testLogic.getStartEndTime(date);
		string expectedMessage = "date";
		string actualMessage = testLogic.filterByDate(testStartEnd);
		Assert::AreEqual(expectedMessage, actualMessage);

		/*filter by priority*/
		string priority = "high";
		char testPriority = testLogic.stringConvertToPriorityChar(priority);
		expectedMessage = "high";
		actualMessage = testLogic.filterByPriority(testPriority);
		Assert::AreEqual(expectedMessage, actualMessage);
		
		 priority = "medium";
		 testPriority = testLogic.stringConvertToPriorityChar(priority);
		expectedMessage = "medium";
		actualMessage = testLogic.filterByPriority(testPriority);
		Assert::AreEqual(expectedMessage, actualMessage);

		priority = "low";
		testPriority = testLogic.stringConvertToPriorityChar(priority);
		expectedMessage = "low";
		actualMessage = testLogic.filterByPriority(testPriority);
		Assert::AreEqual(expectedMessage, actualMessage);
	}
	};


	TEST_CLASS(InitiateCommandActionTest) {
public:
	TEST_METHOD(InitiateCommandActionTest1) {
		Logic testLogic;


		/*Add Item 1*/
		string testInput = "add test item";
		string expectedMessage = "Task added to schedule : test item";
		MESSAGE_AND_SCHEDULE actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*Add Item 2*/
		testInput = "add dinner with young bin";
		expectedMessage = "Task added to schedule : dinner with young bin";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*Add Item 3*/
		testInput = "add dinner with joon fai";
		expectedMessage = "Task added to schedule : dinner with joon fai";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*delete item*/
		testInput = "Delete 2";
		expectedMessage = "Task is deleted from schedule";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*delete item*/
		testInput = "Delete 4";
		try{
			testLogic.initiateCommandAction(testInput);
		}
		catch (string actualDeleteMessage) {
			string expectedDeleteMessage = "Unable to delete task : Invalid index";
			Assert::AreEqual(expectedDeleteMessage, actualDeleteMessage);
		}

		/*add item*/
		testInput = "add go dinner with sophie -date 23:59";
		expectedMessage = "Task added to schedule : go dinner with sophie";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*edit item*/
		testInput = "edit 1";
		expectedMessage = "Unable to edit task : Invalid command";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*edit item*/
		testInput = "edit 1 -desc HAHA";
		expectedMessage = "Task 1 is edited : description ";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*edit item*/
		testInput = "edit 2 -end 12:34";
		expectedMessage = "Task 2 is edited : end ";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*edit item*/
		testInput = "edit 2 -start 13:34";
		expectedMessage = "Unable to edit task : Start Date/Time is later than End Date/Time ";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*sort schedule*/
		testInput = "sort date";
		expectedMessage = "Schedule sorted by : date";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*sort schedule*/
		testInput = "sort update";
		expectedMessage = "Schedule sorted by : update";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*sort schedule*/
		testInput = "sort priority";
		expectedMessage = "Schedule sorted by : priority";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*sort schedule*/
		testInput = "sort name";
		expectedMessage = "Schedule sorted by : name";
		actualMessage = testLogic.initiateCommandAction( testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*sort schedule*/
		testInput = "sort werwefsd";
		expectedMessage = "Invalid command";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*filter schedule*/
		testInput = "view done";
		expectedMessage = "Schedule filtered by : done";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*filter schedule*/
		testInput = "view undone";
		expectedMessage = "Schedule filtered by : undone";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);
		
		/*filter schedule*/
		testInput = "view high";
		expectedMessage = "Schedule filtered by : high";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*filter schedule*/
		testInput = "view med";
		expectedMessage = "Schedule filtered by : medium";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*filter schedule*/
		testInput = "view low";
		expectedMessage = "Schedule filtered by : low";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*filter schedule*/
		testInput = "view 12 apr to 13 apr";
		expectedMessage = "Schedule filtered by : date";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*filter schedule*/
		testInput = "view all";
		expectedMessage = "Schedule filtered by : all";
		actualMessage = testLogic.initiateCommandAction( testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*search task*/
		testInput = "search dinner";
		expectedMessage = "Tasks containing : dinner";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*search task*/
		testInput = "search sophie";
		expectedMessage = "Tasks containing : sophie";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*undo*/
		testInput = "undo";
		expectedMessage = "Last action reversed";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*undo*/
		testInput = "undo 234234";
		expectedMessage = "Invalid command";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*change save file*/
		testInput = "save c:/testFile/testtest";
		expectedMessage = "Save directory changed to : c:/testfile/testtest/save.txt";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*Mark done*/
		testInput = "done 1";
		expectedMessage = "Task 1 is completed";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*Mark done*/
		testInput = "done 4";
		expectedMessage = "invalid line index";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*Mark undone*/
		testInput = "undone 1";
		expectedMessage = "Task 1 is undone";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*Mark undone*/
		testInput = "undone 4";
		expectedMessage = "invalid line index";
		actualMessage = testLogic.initiateCommandAction( testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);


		/*change Save directory*/
		testInput = "save c:/TEST";
		expectedMessage = "Save directory changed to : c:/test/save.txt";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*change Save directory*/
		testInput = "save default";
		expectedMessage = "Save directory changed to : save.txt";
		actualMessage = testLogic.initiateCommandAction(testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);

		/*Clear*/
		testInput = "clear";
		expectedMessage = "Schedule cleared";
		actualMessage = testLogic.initiateCommandAction( testInput);
		Assert::AreEqual(expectedMessage, actualMessage.message);
	}
	};


	TEST_CLASS(TrimTextTest) {
public:
	TEST_METHOD(TrimTextTest1) {
		string testText[] = { "   add text   ", "\t\t del text \t\t\t", "  exit\t\t", " ", "" };
		string expected[] = { "add text", "del text", "exit", "", "" };

		Logic testLogic;
		for (int i = 0; i < 5; i++) {
			testLogic.trimText(testText[i]);
			string actual = testText[i];
			Assert::AreEqual(expected[i], actual);
		}
	}
	};

	TEST_CLASS(RetrieveBasicInformationTest) {
public:
	TEST_METHOD(TrimTextTest1) {
		Logic testLogic;
		string expectedMessage = "Retrieved from save file";
		string actualMessage = testLogic.retrieveBasicInformation();
		Assert::AreEqual(expectedMessage, actualMessage);
	}
	};


	TEST_CLASS(ReadFileWriteFileTest) {
public:
	TEST_METHOD(ReadFileTest1) {
		Logic testLogic;
		string expectedMessage = "readfile completed";
		string actualMessage = testLogic.readDataFromFile();
		Assert::AreEqual(expectedMessage, actualMessage);
	}

	TEST_METHOD(WriteFileTest1) {
		Logic testLogic;
		string expectedMessage = "writefile completed";
		string actualMessage = testLogic.writeDataOntoFile();
		Assert::AreEqual(expectedMessage, actualMessage);
	}
	};

	TEST_CLASS(GetScheduleSizeTest) {
public:
	TEST_METHOD(GetScheduleSizeTest1) {
		Logic testLogic;
		string testItemName;
		COMMAND_AND_TEXT testCommandAndText;
		list<COMMAND_AND_TEXT> testParseInfo;

		/*Add Item 1*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "Young Bin";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 2*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1222 12 12 12 12";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 3*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST2";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "end";
		testCommandAndText.text = "1333 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "M";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 4*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST3";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "start";
		testCommandAndText.text = "1344 11 11 -1 -1";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "L";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		/*Add Item 5*/
		testCommandAndText.command = "add";
		testCommandAndText.text = "TEST4";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "description";
		testCommandAndText.text = "UNITTESTING";
		testParseInfo.push_back(testCommandAndText);
		testCommandAndText.command = "priority";
		testCommandAndText.text = "H";
		testParseInfo.push_back(testCommandAndText);
		testLogic.addTask(testParseInfo);
		testParseInfo.clear();

		testLogic.resetAndGetDisplaySchedule();

		unsigned int expectedSize = 5;
		unsigned int actualSize = testLogic.getScheduleSize();
		Assert::AreEqual(expectedSize, actualSize);

		expectedSize = 5;
		actualSize = testLogic.getDisplayScheduleSize();
		Assert::AreEqual(expectedSize, actualSize);
	}
	};


	TEST_CLASS(KeywordVecTest) {
public:
	TEST_METHOD(ConvertKeywordVecToStringTest1) {
		Logic testLogic;
		string keyword = "hello+hi+test";

		testLogic.convertStringToKeywordVec(keyword);
		string actualMessage = testLogic.convertKeywordVecToString();

		Assert::AreEqual(keyword, actualMessage);
	}
	};


	TEST_CLASS(PriorityTest) {
public:
	TEST_METHOD(PriorityTest1) {
		Logic testLogic;
		string priority = "high";

		char expectedMessage = 'H';
		char actualMessage = testLogic.stringConvertToPriorityChar(priority);
		Assert::AreEqual(expectedMessage, actualMessage);

		priority = "medium";
		expectedMessage = 'M';
		actualMessage = testLogic.stringConvertToPriorityChar(priority);
		Assert::AreEqual(expectedMessage, actualMessage);

		priority = "low";
		expectedMessage = 'L';
		actualMessage = testLogic.stringConvertToPriorityChar(priority);
		Assert::AreEqual(expectedMessage, actualMessage);
		
	}
	};


	TEST_CLASS(GetStartEndTimeTest) {
	public:
		TEST_METHOD(GetStartEndTimeTest1) {
			Logic testLogic;
			string testDate = "date 2015 11 11 00 00 2015 12 12 00 00";
			START_END_TIME testStartEnd = testLogic.getStartEndTime(testDate);
			Assert::AreEqual(testStartEnd.startTime.getYear(), 2015);
			Assert::AreEqual(testStartEnd.startTime.getMonth(), 11);
			Assert::AreEqual(testStartEnd.startTime.getDay(), 11);
			Assert::AreEqual(testStartEnd.startTime.getHour(), 0);
			Assert::AreEqual(testStartEnd.startTime.getMinute(), 0);
			Assert::AreEqual(testStartEnd.endTime.getYear(), 2015);
			Assert::AreEqual(testStartEnd.endTime.getMonth(), 12);
			Assert::AreEqual(testStartEnd.endTime.getDay(), 12);
			Assert::AreEqual(testStartEnd.endTime.getHour(), 0);
			Assert::AreEqual(testStartEnd.endTime.getMinute(), 0);
		}

		TEST_METHOD(InterpretStartEndTimeTest1) {
			Logic testLogic;
			int YYYY = -1;
			int MM = -1;
			int DD = -1;
			int hh = -1;
			int mm = -1;
			
			DateTime interpretedDateTime = testLogic.interpretStartEndTime("start",YYYY, MM, DD, hh, mm);
			Assert::AreEqual(interpretedDateTime.getYear(), 2015);
			Assert::AreEqual(interpretedDateTime.getHour(), -1);
			Assert::AreEqual(interpretedDateTime.getMinute(), -1);
			
			DateTime interpretedDateTime2 = testLogic.interpretStartEndTime("end", YYYY, MM, DD, hh, mm);
			Assert::AreEqual(interpretedDateTime2.getYear(), 2015);
			Assert::AreEqual(interpretedDateTime2.getHour(), 23);
			Assert::AreEqual(interpretedDateTime2.getMinute(), 59);
		}

		TEST_METHOD(InterpretStartEndTimeTest2) {
			Logic testLogic;
			int YYYY = 2015;
			int MM = 11;
			int DD = 12;
			int hh = 13;
			int mm = 14;

			DateTime interpretedDateTime = testLogic.interpretStartEndTime("start", YYYY, MM, DD, hh, mm);
			Assert::AreEqual(interpretedDateTime.getYear(), 2015);
			Assert::AreEqual(interpretedDateTime.getMonth(), 11);
			Assert::AreEqual(interpretedDateTime.getDay(), 12);
			Assert::AreEqual(interpretedDateTime.getHour(), 13);
			Assert::AreEqual(interpretedDateTime.getMinute(), 14);

			DateTime interpretedDateTime2 = testLogic.interpretStartEndTime("end", YYYY, MM, DD, hh, mm);
			Assert::AreEqual(interpretedDateTime2.getYear(), 2015);
			Assert::AreEqual(interpretedDateTime2.getMonth(), 11);
			Assert::AreEqual(interpretedDateTime2.getDay(), 12);
			Assert::AreEqual(interpretedDateTime2.getHour(), 13);
			Assert::AreEqual(interpretedDateTime2.getMinute(), 14);
		}
	};
}

	// End of segment: C:\Users\SKR\Documents\main\iLogicTest\iLogicTest.cpp





	/**
	 * origin: C:\Users\SKR\Documents\main\iPlanner\Main.cpp
	 */

#include "..\iLogic\Logic.h"
#include "..\iParser\iParser.h"

void main() {
	
	Logic testLogic;
	string userInput;
	list<COMMAND_AND_TEXT> parseInfo;

	testLogic.retrieveBasicInformationFromTextFile();
	testLogic.readDataFromFile();
	testLogic.sortTask();

	cout << "command : ";
	while (getline(cin, userInput)){
	testLogic.initiateCommandAction(userInput);
	cout << "command : ";
	}

	return;
}
	// End of segment: C:\Users\SKR\Documents\main\iPlanner\Main.cpp





